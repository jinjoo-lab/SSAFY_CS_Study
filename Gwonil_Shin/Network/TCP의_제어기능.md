# TCP의 제어 기능


[노션](https://night-gecko-97e.notion.site/TCP-a81fd35235ae4e8f8516b536095e6596)

안정적이고 신뢰성 있는 데이터 전송을 가능하게 하고 네트워크에서 발생할수 있는 다양한 상황에 대비할수 있도록 하는 기능

## 흐름 제어

---

수신측이 처리할수 있는 속도로 송신측에서 데이터를 전송하도록 조절하여 수신측의 버퍼 오버플로우로 인한 송신 데이터 손실을 방지하도록 하는 제어

### 처리 조절 로직

수신측이 송신측에게 자신의 상태를 계속 알리는것을 기본 전제로 가지고 시작한다.

- Stop and Wait

  전송한 세그먼트에 대한 응답을 받은 후에 다음 세그먼트을 전송하도록 하는 로직으로 `속도가 잘 안나오고 비 효율적이다.`

- Sliding Window

  수신측에서 설정한 [Window](#window)의 크기 만큼 송신측에서 응답확인 없이 세그먼트를 전송할수 있게하여 데이터의 흐름을 동적을 조절하는 로직

  해당 로직에서는 한번에 `여러 프레임` 을 전송할수 있다.

    - 동작 방식

      ![Untitled](https://night-gecko-97e.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F8c7a5dcd-cd0c-4d92-a660-8919576b5006%2Fcaa25d9a-65cb-46ad-bc3f-8d401eb1bf9f%2FUntitled.png?table=block&id=d95ddd17-829f-462e-b403-5a36e884bd8a&spaceId=8c7a5dcd-cd0c-4d92-a660-8919576b5006&width=1160&userId=&cache=v2)

      window의 크기에 맞게 바이트를 보내고 송신측의 확인 응답이 오면 빈 공간 만큼을 window를 이동시켜 전송 가능상태로 만듬.


## 오류 제어

---

오류의 검출과 재전송에 대한 제어

### 오류 검출 방법

- 송신측이 ACK을 받지 못함 (Timeout)

  수신측이 데이터를 받지 못했거나 수신측이 데이터를 보냈으나 유실된 경우

- 중복된 ACK을 받은 경우
- [NACK](#nacknegative-acknowledgment)을 받은 경우

### 재전송 방식

- Stop and Wait

  ACK을 받고 다음 데이터를 보내는 방식, 비효율적이고 흐름제어의 sliding window를 사용할수 없기에 사실상 안쓰인다.

- Go Back N

  오류 발생 지점부터 재전송하는 방식

  오류 발생 이후 지점에서의 성공적 전송 데이터도 재전송 해야해서 비 효율적이다.

- Selective Repeat

  오류 발생 데이터만 재전송하는 방식

  버퍼의 데이터가 순차적이지 않게 되어 정렬 과정과 별도의 버퍼가 더 필요하다.


## 혼잡 제어

---

네트워크 내의 패킷수가 과도하게 증가하지 않도록 하여 네트워크의 혼잡을 방지하는 제어

### 네트워크가 혼잡하면 어떻게 될까?

라우터나 스위치에서 처리할수 있는 패킷의 양보다 들어오는 패킷의 양이 더 많아지게 되면 대기열에 패킷이 쌓이게 된다.

이로 인해

1. 대기열이 길어져서 응답속도가 느려진다.
2. 대기열이 초과되면서 패킷의 손상/손실이 일어날수 있다.
3. 시간 초과로 인해 재전송이 일어나 네트워크가 더 혼잡해진다.

⇒ 네트워크의 성능이 하락한다.

### 방식

송신측의 데이터 전송속도를 제어하는 것을 기본 로직으로 가지고 한다.

- AIMD(Additive Increase / Multiplicative Decrease)

  최초에 패킷 하나를 보내는것으로 시작해 문제가 없을경우 보내는 양(window Size)을 1씩 늘린다.

  어느순간 전송에 문제가 생길 경우 보내는 양을 절반으로 줄인다.

  송신측의 window size를 하나씩 증가시키다가 혼잡 현상이 발생하면 반으로 줄여버린다.

    - 장점
        - 최종적으로는 모든 호스트가 공평하게 네트워크를 사용하게된다.

          → 결국 모든 호스트가 진입시기를 막론하고 같은 window 사이즈를 가지게 되기 때문

    - 단점
        - 초기 네트워크의 큰 대역폭을 바로 사용하지 못한다.(1씩 증가하여서)
        - 혼잡상태 발생 이후 대역폭을 감소시키는 방식이기에 혼잡 상태를 미리 감지 못한다.
- slow start

  송신측의 window size를 지수승으로 증가시키는 방식(2배씩 키움)으로 혼잡현상이 발생(패킷손실 감지,ssthresh)하면 사이즈를 1로 돌린다.

  ![Untitled](https://night-gecko-97e.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F8c7a5dcd-cd0c-4d92-a660-8919576b5006%2F8aed257b-27de-45d4-9c21-035eb2e4ccd2%2FUntitled.png?table=block&id=c9cd9e26-1a67-4c04-ae83-9252876077e9&spaceId=8c7a5dcd-cd0c-4d92-a660-8919576b5006&width=1380&userId=&cache=v2)

  최초에는 네트워크의 수용량을 모르지만 혼잡현상이 한번 발생하면 수용량을 대략적으로 예상할수 있다.

  따라서 이후에는 혼잡현상이 일어난 크기의 절반은 ssthresh로 두고 해당 시점부터는 윈도우 크기를 1씩 증가시킨다.


### 대응 정책

- TCP Tahoe

  혼합제어의 초기 정책으로 [빠른 재전송](#fast-retransmit)이 처음 도입된 정책.

    - 처음에는 slow start 방식으로 윈도우를 증가시키면서 ssthresh 시점 이후에는 AIMD방식을 사용하는 정책.
        - ssthresh는 [TimeOut](#timeout) 같이 네트워크의 혼잡상황이 발생한 경우 해당 시점의 윈도우 크기의 절반으로 설정함.
    - 문제점
        - 혼잡상황 발생 이후 slow start 구간의 윈도우 크기를 키우는 시간이 오래 걸림.
- TCP Reno

  TCP Tahoe와 동일하지만 3 ACK Duplicated와 TimeOut을 구분하여 처리함. [빠른 회복](#fast-recover)을 적용한 정책


+a) 최근의 혼잡제어

현대의 네트워크의 대역폭은 충분히 커짐. → 윈도우 크기를 확 늘려도 잘 터지지 않음

⇒ `얼마나 빠르게`  윈도우 크기를 늘리며 `혼잡 감지를 똑똑하게 할지` 로 초점이 옮겨짐.

최근의 혼잡 제어 정책

- CUBIC
- RED
- Elastic TCP

## 용어 정리

---

### Window

송신측과 수신측 각각의 버퍼 크기로 데이터를 받을수 있는 공간이라고 생각하면 된다.

### NACK(Negative Acknowledgment)

수신자가 데이터를 제대로 받지 못했거나 처리를 못한경우에 보내는 프로토콜

### Fast Retransmit

특정 순번의 패킷전송에 문제가 생겨서 중복 된 ACK을 3개를 받을경우 재전송이 이루어지도록 하는 매커니즘

### Fast Recover

혼잡 상황에서 윈도우 크기를 1로 줄이지 않고 절반으로 줄이고 선형증가 시키는 매커니즘

### TimeOut

송신측이 데이터를 보낸 이후 일정시간동안 응답을 못받은 혼잡 상황

### 3 ACK Duplicated

송신측이 3번이상 중복된 승인번호를 받은 상황, 특정 시퀀스 이후 데이터를 제대로 처리 못한 상황