# [3주차] HTTP와 HTTPS

## HTTP (HyperText Transfer Protocol)  
클라이언트에서 서버까지의 일련의 흐름을 결정하고 하이퍼텍스트를 전송하는 프로토콜으로, 애플리케이션 계층에 속한다. 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.   
HTTP로 HTML, TEXT뿐만 아니라 이미지, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터가 전송 가능하며 서버 간 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.   
HTTP/1.1, HTTP/2는 TCP 기반, HTTP/3은 UDP 기반이며 현재는 HTTP/1.1을 주로 사용한다.  
HTTP는 **클라이언트 서버 구조**로 리소스를 요구하는 클라이언트와 리소스를 제공하는 서버 간에 통신을 하며, 클라이언트의 리퀘스트에 대한 응답으로 서버의 리스폰스가 송신된다.

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/fe6822f8-faa5-4145-a0f3-3dc8a098e233)

HTTP 메시지 구조를 정리하면 다음과 같이 단순하며 확장 가능하다.
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/54ff75e3-1d10-4896-a98f-8d455dd4bdec)

### Stateless
HTTP는 많은 데이터를 빠르고 확실하게 처리하는 **범위성(scalavility)** 을 확보하기 위해 상태를 유지하지 않는 **Stateless** 프로토콜이다.   
항상 같은 서버가 유지되어야 하는 **Stateful(상태 유지)** 과 달리 **Stateless(무상태)** 는 응답 서버를 쉽게 바꿀 수 있어 서버 장애 시 빠른 대응과 무한한 서버 증식(스케일 아웃)이 가능하다.  
또한 서버의 CPU나 메모리같은 리소스의 소비를 억제할 수 있으며 프로토콜을 단순하게 해준다.  

그러나, 모든 것을 무상태로 설계할 수 있지는 않다. 무상태의 경우 전송되는 데이터량이 비교적 많고, 로그인과 같은 경우는 상태 유지가 필요하다.   
이러한 경우 브라우저 쿠키나 서버 세션을 사용해 상태를 유지하는데, 결론적으로 웹 애플리케이션 설계 시에는 최소한의 상태 유지를 사용하는 것이 좋다.  

정리하자면, HTTP는 기본적으로 연결을 유지하지 않는 모델로 클라이언트의 요청에 응답 후 연결을 끊어 서버 자원을 효율적으로 사용한다.   
즉. 클라이언트와 서버가 요청과 응답을 주고받으면 연결이 끊어지고, 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.  
그러나 이러한 방식은 TCP/IP 연결을 매번 새로 맺어야 하므로 비교적 시간이 소요되며, 웹 브라우저로 사이트 요청 시에는 매번 수많은 자원들이 다운로드되는 한계가 있어 **지속 연결(Persistent Connections)** 을 사용한다.  

### 지속 연결
HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 해야 할 필요가 있었는데, HTTP가 널리 보급 되어감에 따라 다량의 이미지를 포함한 문서 등이 늘어났고, 리퀘스트를 보낼 때마다 매번 연결과 종료를 하는 불필요한 과정을 해결하기 위해 **지속 연결(Persistent Connections)** 이 고안되었다.
이는 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 것을 의미하며, 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내짐을 의미한다.  

지속 연결은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주어 서버에 대한 부하가 경감되고 웹 페이지를 빨리 표시할 수 있다는 이점이 있다.
또한 리퀘스트를 병행해서 보내는 **파이프라인화(HTTP Pipelining)** 가 가능하게 한다. 즉, 일일이 리스폰스를 기다리지 않고 다음 리퀘스트를 보낼 수 있다.  
일반적으로 HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다. 

HTTP의 디폴트 모드가 지속 연결이나 비지속 연결을 사용하도록 설정할 수도 있다.
한편, 비지속 연결의 경우 각 요청 객체에 대한 새로운 연결이 설정 및 유지되어ㅑ 하므로 연결에 1RTT(round-trip-time), 객체를 요청하고 응답받는 HTTP 요청/응답에 1RTT, 파일 전송시간까지 총 2RTT + 파일 전송시간이 소요된다.  
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/894504ac-88ad-46b2-8dee-c3211b93f6c3)

## HTTPS
HTTP의 약점을 해결하기 위해 HTTPS가 등장. 우선 이를 간단히 정리하면 다음과 같다.    
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/a996b2d0-5f43-470d-9aa0-68a7393d0abc)

HTTP에 암호화나 인증 등의 구조를 더해 기밀성, 데이터 무결성, 인증으로 서비스를 향상시킨 것을 **HTTPS(HTTP Secure)** 라고 부른다.  

여기서 기밀성, 메시지 무결성, 종단점 인증은 운영 보안과 더불어 **안전한 통신** 에 요구되는 특성이며 아래에서 설명하곘음

HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아니며, HTTP 통신을 하는 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체한 형태이다.  
HTTP는 보통 TCP와 직접 통신하지만 SSL을 사용하는 경우에는 HTTP는 SSL과 통신하고, SSL이 TCP와 통신하게 된다.

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/45817eba-00c7-499d-8be4-fd010667dab6)

HTTP가 SSL을 사용하면 HTTPS로서 암호화, 증명서, 완전성 보호를 이용할 수 있게 되며, 이때 SSL은 HTTP와는 독립된 프로토콜이다.

<details>
<summary>SSL와 TLS</summary>
<div markdown="1">
SSL과 TLS 모두 데이터를 암호화하는 통신 프로토콜.
SSL의 향상된 버전이 TLS이며 현재는 TLS가 사용되고 있다.   
SSL과 TLS를 혼용해 부르나 편의상 TLS로 통일하겠음
</div>
</details>

### HTTPS 통신 구조

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/fb786c49-f83e-4b15-b3c3-e11b9fc44cbe)

TLS handshake는 HTTPS 프로토콜을 사용하기 위해 서버와 클라이언트가 수행하는 과정으로 보안 연결에 필요한 암호화 방식 교환, 암호화 키 생성과 TLS 인증서 인증 등이 핵심이다.

**Cipher Suites 교환 및 협상**
클라이언트인 웹 브라우저는 Chrome, Safari, Firefox 등 다양한 브라우저가 존재하고 서버도 Nginx, Apache 등 다양한 환경으로 구성된다.  
각각의 구성 환경에서 제공되는 기능은 다양하기 때문에 우선 클라이언트와 서버에서 사용할 암호화 방식을 선정해야 한다.
이것이 TLS handshake 의 첫번째 역할이며, 클라이언트는 사용 가능한 암호화 방식(Cipher Suites) 를 보내며 서버는 암호화 방식(Cipher Suite)을 선정하여 TLS 인증서를 전송하게 된다.

**인증서 인증**
클라이언트는 서버가 전송한 TLS 인증서를 검증하는 작업이 필요하다.  
신뢰 가능한 보안 연결에 필수적인 작업으로 TLS 인증서 검증을 통해 클라이언트가 통신을 시작할 서버가 신뢰할 수 있는 웹사이트인지 판단한다.
또한 이 과정에서 인증서가 검증이 되었다면 서버의 개인키 역시 확인해야 한다.   
모든 TLS 인증서는 서버의 공개키도 구성되어 있으며 해당 공개키의 쌍인 서버의 개인키가 유효한지 검증 작업도 수행해야 한다.

**Session Key 생성 및 교환**
TLS handshake 의 마지막 작업으로 실제 보안 통신에 사용할 “Session Key” 를 구성하여 교환해야 한다.
Session Key 는 대칭키로 구성된다.
비대칭키는 암호화 복호화 작업에 대해서 리소스 자원이 많이 들게 되므로 대칭키를 사용하여 보다 효율적인 보안 통신을 수행한다.

TLS handshake 에서 키 교환까지 완료되면 서버와 클라이언트는 각각 작업의 완료를 알리며 체크섬을 통해 handshake 과정에서 변조나 손상이 없는지 확인한다.  

여기에 덧붙여 애플리케이션 계층의 데이터를 송신할 때는 MAC(Message Authentication Code)라는 메시지 다이제스트를 덧붙여 변조를 감지하고 완전성 보호를 실현할 수 있다.

## 데이터 기밀성
송신자와 지정된 수신자만이 전송되는 메시지 내용을 이해할 수 있어야 한다. 도청자가 해석할 수 없도록 메시지나 통신을 암호화하는 것 


### 공개키 암호화 방식
SSL에서는 공개키 암호화 방식을 채택하고 있다.

> **대칭키 암호화**   
> 암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키(대칭키) 암호 라고 부른다. 공통키 암호 방식은 상대에게 안전하게 키를 배송하고, 받은 키를 안전하게 보관하는 것이 중요하다.
> 이러한 문제를 해결하기 위해 공개키 암호 방식이 사용된다.

공개키 암호는 서로 다른 두개의 키 페어(비밀키와 공개키)를 사용한다. 암호를 보내는 측이 상대의 공개키를 이용해 암호화를 하고, 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시한다.  
이 방식은 암호를 푸는 비밀키를 통신으로 보낼 일이 없기 때문에 도청에 의해 키를 빼앗길 걱정이 없으며, 암호문과 공개키에서 평문을 구하는 것은 매우 어려운 수학적 특징이 있어 간단하지 않다.

HTTPS는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템이다. 키를 안전하게 교환할 수만 있다면 공개키 암호만을 사용해 통신을 해도 괜찮다고 생각할 수 있으나 공개키 암호는 공통키 암호에 비해 처리 속도가 늦다.  
두 방식의 장점을 살릴 수 있도록 키를 교환하는 곳에는 공개키 암호를 사용하고, 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.

## 데이터 무결성
통신하는 내용이 전송 도중에 변경되지 않았음을 체크섬 기술을 확장해 확인

### 암호화 해시 함수
임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜 주는 함수를 해시함수라고 한다.
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/d24ab842-9222-42c3-bd38-4707835394c1)   
클라이언트가 메시지와 메시지를 암호화 해시 함수를 이용해 해싱한 값을 함께 서버로 전달. 서버는 자신의 암호화 해시함수로 메시지를 해싱한 후 이 값이 클라이언트로부터 받은 값과 동일한지 여부로 데이터의 무결성 판단.

## 통신 상대 인증
송신자와 수신자가 통신에 참여하는 상대방이 실제 누구인지 확인하기 위해 상대방의 신원을 확인하는 것
### 증명서
상대가 정상 서버인지 아닌지를 증명할 수 없다. 이를 해결하기 위해 인증 기관과 인증 기관이 발행하는 공개키 증명서가 이용되고 있다.

인증 기관은 다음과 같이 이용된다.

1. 서버 운영자가 인증 기관에 공개키를 제출한다.
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 암호화해 공개키 인증서에 서명이 끝난 공개키를 담는다.
3. 서버는 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신한다.
4. 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해 서버의 공개키를 신뢰할 수 있다.
5. 인증 기관의 공개키는 안전하게 클라이언트에 전달되어야 한다. 통신 중에는 어려운 문제이므로 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓는다.

조직의 실제성을 증명하는 EV SSL 증명서도 있으며, 클라이언트를 확인하는 클라이언트 증명서도 이용이 가능하다. 그러나 클라이언트 증명서는 증명서의 입수와 배포에 비용이 소모되며, 클라이언트의 실재를 증명할 뿐 사용자의 존재 유무를 증명하는 증명서는 아니라는 문제점이 있다.

SSL은 인증 기관을 신용할 수 있다는 전제로 이루어져 있으며, 독자적으로 구축한 인증 기관을 자기 인증 기관이라 부르고 여기서 발행한 쓸모 없는 증명서를 비하해 ‘나야 나 증명서’라고 부르기도 한다. 마이너 인증 기관을 사용하면 ‘나야 나 증명서’ 가 될 수도 있다.

> **인증서 체인**  
> 엔티티를 인증하는 데 사용되는 인증서 목록이자 경로로, 신뢰 체인은 CA에서 발급한 루트 인증서(Root Certificate)부터 하나 이상의 중간 인증서(Intermediate Certificate) 및 서버 인증서(Leaf Certificate)로 구성되어 있다.     
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/c6e4c5dd-a502-46a4-80db-c1e102a92d5f)  
> **루트 인증서**: 신뢰 체인 모델의 핵심으로 엄격하게 관리되며 중간 인증서를 발급하는데 사용한다. 전송을 통해 관리하기 적절하지 않으므로 루트 저장소에서 관리된다.   
> **중간 인증서**: 서버 인증서와 루트 인증서의 중개자 역할을 한다.  루트 인증서의 손상은 루트 인증서부터 신뢰를 얻는 모든 인증서가 재발급되어야 하는 상황이 생기므로 중간 인증서를 사용하여 최종 사용자에게 서버 인증서를 발급하는 방식으로 보안 수준을 높일 수 있다.   
>  루트 CA가 개인키로 중간 CA의 중간 인증서에 서명하면 중간 인증서는 신뢰할 수 있는 인증서가 되고, 해당 중간 CA 는 중간 인증서로 다른 중간 CA 의 인증서 혹은 최종 서버 인증서에 서명할 수 있게 된다.  
> 이러한 방식을 이용하면 루트 CA 는 오프라인 상태로 중간 CA 의 인증서 발급을 위해서만 사용되므로 루트 CA 의 역할을 분산할 수 있으며 중간 CA 인증서의 문제가 발생한 경우 해당 중간 CA 부터 시작하는 분기의 인증서만 재발급하면 된다.  
> **서버 인증서**: End Entity Certificate 로 평소에 TLS/SSL 인증서로 불리는 인증서이며 개발자가 구매하는 SSL 인증서는 보통 서버 인증서를 의미한다.
> 서버와 사용자 간의 민감한 통신을 보호/암호화할 수 있도록 서버에 설치하는 암호화된 데이터가 포함된 텍스트 파일이며 중간 CA 의 개인키로 암호화된다. 

### 인증서 유효성 검사 프로세스  
1. 브라우저가 홈페이지에 접근하여 인증서 체인을 다운받는다.
2. 브라우저는 다운받은 인증서 체인에 따라 역추적을 시작.
3. 인증서 체인과정(역추적)은 브라우저가 신뢰할 수 있는 기관(루트 CA) 목록의 인증서를 확인할때까지 계속되며, 만약 TLS 인증서의 루트 인증서까지 도달했지만 브라우저가 신뢰할 수 있는 기관의 인증서가 아닌경우 브라우저는 신뢰할 수 없다고 경고.

### TLS 전체 프로세스
웹 서버의 인증서 구성부터 클라이언트에서 인증서 검증까지의 프로세스  

1. 서버는 개인키와 공개키를 생성.
2. 서버는 서버의 공개키와 서버의 정보를 포함한 CSR(인증서 서명 요청)을 생성.
3. CSR 를 통해 중간 CA 에 TLS 인증서 발급을 요청.
4. 중간 CA 는 CSR 에 대한 검증이 끝나면 서버의 공개키를 해시하고 CA 개인키로 서명한 서버 인증서를 구성.
5. 웹 서버는 중간 CA 에서 구성된 서버 인증서를 설치하고 인증서의 신뢰도 보장을 위해 중간 CA 의 중간 인증서까지 설치.
6. 클라이언트가 서버와 연결을 시도하고 TLS handshake 과정 시작.
7. TLS handshake 과정 중 서버는 클라이언트에게 인증서 체인을 전송.
8. 인증서 체인을 전송받은 클라이언트는 루트 저장소에 저장된 신뢰할 수 있는 CA 의 인증서인지 유효성 검사를 시작.
9. 서버로부터 받은 인증서 체인의 루트 인증서가 신뢰할 수 있는 CA 의 인증서로 검증되면 유효성 검사가 종료.

### 단점
SSL을 사용하면 처리가 늦어지게 된다는 단점이 있는데 원인은 다음과 같다.

1. TCP 접속과 HTTP 리퀘스트/리스폰스 이외에 SSL에 필요한 통신이 추가되면서 전체적으로 처리할 통신이 증가하여 통신 속도가 떨어진다.
2. SSL은 반드시 암호화 처리를 하고 있기 때문에 암호화나 복화화를 위한 계산 때문에 CPU나 메모리 등의 리소스를 다량으로 소비한다.

네트워크 부하는 HTTP에 비해 2-100배 느리나, 이를 근본적으로 해결할 방법은 없기 때문에 SSL 엑셀레이터라는 하드웨어를 사용하여 해결하기도 한다.   
이러한 이유로 항상 HTTPS를 사용하지는 않으며 민감한 정보를 포함하지 않는 통신에서는 HTTP를 사용하고, 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다.  
HTTPS를 사용하기 위해서 증명서가 필요하기 떄문에 이러한 비용이 부담되는 서비스나 개인적인 웹 사이트에서는 HTTP만 선택하는 경우도 있다.

# Reference
그림으로 배우는 Http & Network Basic - 우에노 센  
컴퓨터 네트워킹 하향식 접근 - James F. Kuroese, Keith W. Ross  
[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)   
[[10분 테코톡] 헤나의 HTTPS](https://www.youtube.com/watch?v=KpyzbEFYE_E)  
[Certificate Chain](https://dongmin-tech.tistory.com/17)    
[IBM - 인증서 체인이 작동하는 방법](https://www.ibm.com/docs/ko/ibm-mq/7.5?topic=ssfksj-7-5-0-com-ibm-mq-sec-doc-q009880--htm)