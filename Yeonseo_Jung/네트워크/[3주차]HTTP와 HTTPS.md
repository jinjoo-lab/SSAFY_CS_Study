# [3주차] HTTP와 HTTPS

## HTTP (HyperText Transfer Protocol)  
클라이언트에서 서버까지의 일련의 흐름을 결정하고 하이퍼텍스트를 전송하는 프로토콜으로, 애플리케이션 계층에 속한다. 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.   
HTTP로 HTML, TEXT뿐만 아니라 이미지, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터가 전송 가능하며 서버 간 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.   
HTTP/1.1, HTTP/2는 TCP 기반, HTTP/3은 UDP 기반이며 현재는 HTTP/1.1을 주로 사용한다.  
HTTP는 **클라이언트 서버 구조**로 리소스를 요구하는 클라이언트와 리소스를 제공하는 서버 간에 통신을 하며, 클라이언트의 리퀘스트에 대한 응답으로 서버의 리스폰스가 송신된다.

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/fe6822f8-faa5-4145-a0f3-3dc8a098e233)

HTTP 메시지 구조를 정리하면 다음과 같이 단순하며 확장 가능하다.
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/54ff75e3-1d10-4896-a98f-8d455dd4bdec)
### HTTP 메서드
| 메소드     | 설명                                                                                                                                              | 리퀘스트 예시                                                                                   | 리스폰스 예시                                                                                                                                                               | 제공하고 있는 HTTP 버전 |
|:--------|:------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------|
| GET     | 리소스 획득. <br/>리퀘스트 URI로 식별된 리소스를 가져오도록 요구                                                                                                        | GET /index.html HTTP /1.1<br/>Host: www.hackr.jp <br/>와 같은 형식                             | index.html 리소스를 되돌려 준다.<br/>텍스트이면 그대로 반환, 프로그램이면 실행해서 출력된 내용을 돌려준다.                                                                                                   | 1.0 1.1        |
| POST    | 엔티티 전송. GET도 가능하나 일반적으로는 POST를 사용한다.                                                                                                            | POST /submit.cgi HTTP /1.1<br/>Host: www.hackr.jp<br/>Content-Length: 1500(1500 바이트 데이터)  | submit.cgi가 수신한 데이터의 처리 결과를 되돌려준다.                                                                                                                                    | 1.0 1.1        |
| PUT     | 파일 전송. 리퀘스트 중에 포함된 엔티리를 리퀘스트 URI로 지정한 곳에 보존하도록 요구.<br/>보안 상의 문제로 일반적인 사이트에서는 보통 사용되지 않고, 인증 기능과 짝을 이루거나 웹끼리 연계하는 설계 양식 사용 시에 이용한다.              | PUT /example.html HTTP /1.1<br/>Host: www.hackr.jp<br/>Content-Length: 1500(1500 바이트 데이터) | 상태 코드 204 No Content 리스폰스를 되돌려준다.                                                                                                                                     | 1.0 1.1        |
| HEAD    | 메시지 헤더 취득. GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. <br/>URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용.                                                             | HEAD /index.html HTTP /1.1<br/>Host: www.hackr.jp                                         | index.html에 관련된 리스폰스 헤더를 돌려준다.                                                                                                                                        | 1.0 1.1        |
| DELETE  | 파일 삭제. PUT과 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구. 일반적인 사이트에서는 보통 이용되지 않고, 인증 기능과 짝을 이루거나 REST를 사용하는 경우에 사용                                        | DELETE /example.html HTTP /1.1<br/>Host: www.hackr.jp                                     | 상태 코드 204 No Content의 리스폰스를 되돌려준다. example.html은 서버상에서 삭제되어 있다.                                                                                                       | 1.0 1.1        |
| OPTIONS | 제공하고 있는 메소드의 문의                                                                                                                                 | OPTIONS * HTTP /1.1<br/>Host: www.hackr.jp                                                | HTTP /1.1 200 OK<br/>Allow:GET,POST,HEAD,OPTIONS<br/>(서버가 제공하고 있는 메소드를 되돌려준다)                                                                                         | 1.1            |
| TRACE   | 경로 조사. Web 서버에 접속해 자신에게 통신을 되돌려 받는 루프백을 발생시킨다. 리퀘스트에 "Max-Fowards" 라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 수치를 줄여가고, 수치가 0이 된 곳을 끝으로 상태 코드 200 OK를 되려준다. | TRACE / HTTP /1.1<br/>Host: hackr.jp<br/>Max-Forwards: 2                                  | HTTP /1.1 200 OK<br/>Content-Type: message/http<br/>Content-Lenght:1024 <br/><br/>Trace / HTTP /1.1<br/>Host: hackr.jp<br/>Max-Forwards:2(리퀘스트 내용을 리스폰스에 포함해서 되돌려준다.) | 1.1            |
| CONNECT | 프록시에 터널링 요구. TCP 통신을 터널링 시키기 위해 사용되며 주로 SSL이랑 TSL등의 프로토콜로 암호화 된 것을 터널링 시키기 위해 사용되고 있다. <br/>메소드의 양식은 `CONNECT 프록시 서버: 포트 HTTP 버전` 으로 이루어져 있다.   | CONNECT proxy.hackr.jp:8080 HTTP /1.1<br/>Host: proxy.hackr.jp                            | HTTP /1.1 200 OK (그 뒤에 터널링을 개시)                                                                                                                                       | 1.1 |

### HTTP 상태코드
클라이언트가 서버에게 리퀘스트를 보낼 때, 서버 측에서 그 결과가 어떻게 되었는지 알려주는 것을 **상태 코드** 라고 한다.

|     | 클래스           | 설명                      | 대표 코드                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
  |:----|:--------------|:------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1xx | Informational | 리퀘스트를 받아들여 처리중          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 2xx | Success       | 리퀘스트를 정상적으로 처리          | **200 OK** 클라이언트가 보낸 리퀘스트를 서버가 정상처리했음. 상태 코드와 함께 되돌아 오는 정보는 메소드에 따라 다르다.<br/>**204 No Content** 서버가 리퀘스트를 받아 처리하는 데는 성공했지만 리스폰스에 엔티티 바디를 포함하지 않는다. 클라이언트에서 서버에 정보를 보내는 것으로 족한 경우에 사용됨.<br/>**206 Partial Conent** Range에 의해 범위가 지정된 리퀘스트에 의해 서버가 부분적 GET 리퀘스트를 받았음. 리스폰스에는 지정된 범위의 엔티티가 포함됨                                                                                                                                                                                                                                                                             |
| 3xx | Redirection   | 리퀘스트를 완료하기 위해 추가 동작이 필요 | **301 Moved Permanently** 리퀘스트된 리소스에는 새로운 URI가 부여되어 있으므로 이후로는 그 리소스를 참조하는 URI를 사용해야 함을 나타낸다.<br/>**302 Found** 301과 비슷하지만 301은 영구적인 이동인 반면 302는 일시적이며 앞으로 이동될 가능성이 있다. **303 See Other** 리퀘스트에 대한 리소스는 다른 URI에 있기 때문에 GET 메소드를 사용해서 얻어야 함을 의미. 302와 같은 기능이지만 리다이렉트 장소를 GET으로 얻어야 한다고 명확하게 명시한다는 차이가 있음<br/>**304 Not Modififed** 클라이언트가 조건부 리퀘스트를 했을 때 리소스에 대한 액세스는 허락하지만 조건이 충족되지 않음을 표시. 리스폰스 바디에 어떤 것도 포되서는 안되며 리다이렉트와는 사실 관계가 없다.<br/>**307 Temporary Redircet**                                                                                                    |
| 4xx | Client Error  | 서버는 리퀘스트 이해 불가능         | **400 Bad Request** 리퀘스트 구문이 잘못되었음. 리퀘스트 내용을 재검토하고 나서 재송신할 필요가 있으며 브라우저는 이것을 200 OK와 같이 취급한다.<br/>**401 Unauthoroizezd** 송신한 리퀘스트에 HTTP 인증(BASIC, DIGEST 인증) 정보가 필요하다는 것을 나타내며, 리스폰스를 되돌리는 경우에는 리퀘스트 된 리소스에 적용되는 challenge를 포함한 WWW-Authenticate 헤더 필드를 포함할 필요가 있다. 최초의 401인 경우는 인증을 위한 다이얼로그가 표시되며 두번째 리스폰스에 경우에는 인증에 실패했음을 표시한다. <br/>**403 Forbidden** 리퀘스트된 리소스의 액세스가 거부되었음. 거부의 이유를 명확하게 하는 경우에는 엔티티 바디에 기재해서 유저 측에 표시한다. 퍼미션이 부여되지 않은 경우나 액세스 권한 문제 등이 포함된다.<br/>**404 Not Found** 리퀘스트한 리소스가 서버상에 없다는 것을 나타내며, 서버 측에 해당 리퀘스트를 부하고 싶은 이유를 분명히 하고 싶지 않은 경우에도 이용한다. |
| 5xx | Server Error  | 서버는 리퀘스트 처리 실패          | **500 Internal Server Error** 서버에서 리퀘스트를 처리하는 도중에 에러가 발생하였음. 웹 애플리케이션에 에러가 발생한 경우 일시적인 경우도 있다.<br/>**503 Service Unavailable** 일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음. 상태가 해소되기까지 시간이 걸리는 경우에는 Retry-After 헤더 필드에 따라 클라이언트에 전달하는 것이 바람직하다.                                                                                                                                                                                                                                                                                                                     |

클래스의 정의만 지킨다면 상태 코드를 변경하거나 서버 독자의 상태 코드를 만들어도 무관하다. [RFC2616](https://www.rfc-editor.org/rfc/rfc2616)과 WebDAV의 확장을 포함하면 상태 코드는 60가지 이상이지만 실제로 자주 사용되고 있는 것은 14가지 정도이다.

상태 코드가 현재 상황과 불일치할 수도 있음을 유념하자.

### HTTP 헤더 
HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있으며 가장 다양한 정보를 가지고 있는 것이 HTTP 헤더 필드이다.

메시지 헤더에는 클라이언트와 서버 처리에 필요한 주요 정보가 들어 있으며, 메시지 바디에는 사용자와 리소스를 필요로 하는 정보가 담겨 있다.

### HTTP 헤더 필드
HTTP의 구성 요소 중 하나로 메시지 바디의 크기나 사용 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용되고 있다.

`헤더 필드명: 필드 값` 으로 구성되어 있으며 하나의 헤더 필드가 여러 개의 필드 값을 가질 수 있다.

일반적으로 용도에 따라 다음의 4종류로 분류된다.

#### 일반적 헤더 필드(General Header Fields)
리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더

| 헤더 필드 명           | 설명                    |
|:------------------|:----------------------|
| Cache-Control     | 캐싱 동작 지정              |
| Connection        | Hop-by-Hop 헤더, 커넥션 관리 |
| Date              | 메시지 생성 날짜             |
| Pragma            | 메시지 제어                |
| Trailer           | 메시지의 끝에 있는 헤더의 일람     |
| Transfer-Encoding | 메시지 바디의 전송 코딩 형식 지정   |
| Upgrade           | 다른 프로토콜에 업그레이드        |
| Via               | 프록시 서버에 관한 정보         |
| Warning           | 에러 통지                 |

#### 리퀘스트 헤더 필드(Request Header Fields)
클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로, 리퀘스트의 부가적 정보와 클라이언트 정보, 리스폰스 콘텐츠에 관한 우선 순위 등을 부가한다.

| 헤더 필드 명             | 설명                                   |
|:--------------------|:-------------------------------------|
| Accept              | 유저 에이전트가 처리 가능한 미디어 타입               |
| Accept-Charset      | 문자셋 우선 순위                            |
| Accept-Encoding     | 콘텐츠 인코딩 우선 순위                        |
| Accept-Language     | 언어(자연어) 우선 순위                        |
| Authorization       | 웹 인증을 위한 정보                          |
| Expect              | 서버에 대한 특정 동작의 기대                     |
| From                | 유저의 메일 주소                            |
| Host                | 요구된 리소스의 호스트                         |
| If-Match            | 엔티티 태그의 비교                           |
| If-Modified-Since   | 리소스 갱신 시간 비교                         |
| If-None-Match       | 엔티티 태그의 비교(If-Match의 반대)             |
| If-Range            | 리소스가 갱신되지 않은 경우, 엔티티의 바이트 범위의 요구를 송신 |
| If-Unmodified-Since | 리소스의 갱신 시간 비교(If-Modified-Since의 반대) |
| Max-Forwards        | 최대 전송 홉 수                            |
| Proxy-Authorization | 프록시 서버의 클라이언트 인증을 위한 정보              |
| Range               | 엔티티 바이트 범위 요구                        |
| Referer             | 리퀘스트중의 URI를 취득하는 곳                   |
| TE                  | 전송 인코딩의 우선 순위                        |
| User-Agent          | HTTP 클라이언트의 정보                       |


#### 리스폰스 헤더 필드(Response Header Fields)
서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로, 리스폰스 정보와 서버 정보, 클라이언트의 추가 정보 요구 등을 부가한다.

| 헤더 필드 명            | 설명                       |
|:-------------------|:-------------------------|
| Accept-Ranges      | 바이트 단위의 요구를 수신할 수 있는지 여부 |
| Age                | 리소스의 지정 경과 시간            |
| Etag               | 리소스를 특정하기 위한 정보          |
| Location           | 클라이언트를 지정한 URI에 리다이렉트    |
| Proxy-Authenticate | 프록시 서버의 클라이언트 인증을 위한 정보  |
| Retry-After        | 리퀘스트 재시행의 타이밍 요구         |
| Server             | HTTP 서버 정보               |
| Vary               | 프록시 서버에 대한 캐시 관리 정보      |
| WWW-Authenticate   | 서버의 클라이언트 인증을 위한 정보      |

#### 엔티티 헤더 필드(Entity Header Fields)
리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용하는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.

| 헤더 필드 명          | 설명                   |
|:-----------------|:---------------------|
| Allow            | 리소스가 제공하는 HTTP 메소드   |
| Content-Encoding | 엔티티 바디에 적용되는 콘텐츠 인코딩 |
| Content-Language | 엔티티의 자연어             |
| Content-Length   | 엔티티 바디의 사이즈(바이트 단위)  |
| Content-Location | 리소스에 대응하는 대체 URI     |
| Content-MD5      | 엔티티 바디의 메시지 다이제스트    |
| Content-Range    | 엔티티 바디의 범위 위치        |
| Content-Type     | 엔티티 바디의 미디어 타입       |
| Expires          | 엔티티 바디의 유효기한 날짜      |
| Last-Modified    | 리소스의 최종 갱신 날짜        |

#### HTTP/1.1 이외의 헤더 필드
[RFC4229 Header Field Registrations](https://datatracker.ietf.org/doc/html/rfc4229)에 정리되어 있다.

쿠키와 관련된 헤더 필드나

| 헤더 필드 명    | 설명                       |
|:-----------|:-------------------------|
| Set-Cookie | 상태 관리 개시를 위한 쿠키 정보, 리스폰스 |
| Cookie     | 서버에서 수신한 쿠키 정보, 리퀘스트     |

독자적인 헤더 필드가 있다.

| 헤더 필드 명          | 설명                                                               |
|:-----------------|:-----------------------------------------------------------------|
| X-Frame-Option   | 다른 웹사이트의 프레임에서 표시 제어. 클릭 재킹 공격을 막는 것을 목적으로 함                     |
| X-XSS-Protection | 크로스 사이트 스크립팅(XSS)의 대책으로서 브라우저의 XSS 보호 기능 제어                      |
| DNT              | Do Not Track이라는 뜻으로 개인 정보 수집 거부 의사를 나타냄                          |
| P3P              | 웹 사이트 상의 프라이버시 정책에 P3P(The Platform for Privacy Preferences)를 사용 |

### End-to-end 헤더와 Hop-by-hop 헤더
캐시와 비캐시 프록시의 동작을 정의하기 위해 두가지 카테고리로 분류된다.

**End-to-end 헤더**는 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안 된다.
**Hop-by-hop 헤더**는 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해 전송되지 않는 것도 있다.

Connection, Keep-Alve, Proxy-Authenticate, Proxy-Authorization, Trailer, TE, Transfer-Encoding, Upgrade가 Hop-by-hop 헤더에 해당하며, 이외에는 모두 End-to-end 헤더로 분류된다.

### Stateless
HTTP는 많은 데이터를 빠르고 확실하게 처리하는 **범위성(scalavility)** 을 확보하기 위해 상태를 유지하지 않는 **Stateless** 프로토콜이다.   
항상 같은 서버가 유지되어야 하는 **Stateful(상태 유지)** 과 달리 **Stateless(무상태)** 는 응답 서버를 쉽게 바꿀 수 있어 서버 장애 시 빠른 대응과 무한한 서버 증식(스케일 아웃)이 가능하다.  
또한 서버의 CPU나 메모리같은 리소스의 소비를 억제할 수 있으며 프로토콜을 단순하게 해준다.  

그러나, 모든 것을 무상태로 설계할 수 있지는 않다. 무상태의 경우 전송되는 데이터량이 비교적 많고, 로그인과 같은 경우는 상태 유지가 필요하다.   
이러한 경우 브라우저 쿠키나 서버 세션을 사용해 상태를 유지하는데, 결론적으로 웹 애플리케이션 설계 시에는 최소한의 상태 유지를 사용하는 것이 좋다.  

정리하자면, HTTP는 기본적으로 연결을 유지하지 않는 모델로 클라이언트의 요청에 응답 후 연결을 끊어 서버 자원을 효율적으로 사용한다.   
즉. 클라이언트와 서버가 요청과 응답을 주고받으면 연결이 끊어지고, 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.  
그러나 이러한 방식은 TCP/IP 연결을 매번 새로 맺어야 하므로 비교적 시간이 소요되며, 웹 브라우저로 사이트 요청 시에는 매번 수많은 자원들이 다운로드되는 한계가 있어 **지속 연결(Persistent Connections)** 을 사용한다.  

스테이트리스 특징은 남겨둔 채 문제를 해결하기 위해 **쿠키(Cookie)** 등장

쿠키는 리퀘스트와 리스폰스에 정보를 추가하여 클라이언트의 상태를 파악하게 해주는 시스템이다. 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키는 클라이언트에 보존되고, 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때는 자동으로 이 쿠키 값을 넣어 송신한다. 서버는 클라이언트의 쿠키를 확인로 서버 상의 기록을 확인한 뒤 이전 상태를 파악한다.

### 지속 연결
HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 해야 할 필요가 있었는데, HTTP가 널리 보급 되어감에 따라 다량의 이미지를 포함한 문서 등이 늘어났고, 리퀘스트를 보낼 때마다 매번 연결과 종료를 하는 불필요한 과정을 해결하기 위해 **지속 연결(Persistent Connections)** 이 고안되었다.
이는 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 것을 의미하며, 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내짐을 의미한다.  

지속 연결은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주어 서버에 대한 부하가 경감되고 웹 페이지를 빨리 표시할 수 있다는 이점이 있다.
또한 리퀘스트를 병행해서 보내는 **파이프라인화(HTTP Pipelining)** 가 가능하게 한다. 즉, 일일이 리스폰스를 기다리지 않고 다음 리퀘스트를 보낼 수 있다.  
일반적으로 HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다. 

HTTP의 디폴트 모드가 지속 연결이나 비지속 연결을 사용하도록 설정할 수도 있다.
한편, 비지속 연결의 경우 각 요청 객체에 대한 새로운 연결이 설정 및 유지되어ㅑ 하므로 연결에 1RTT(round-trip-time), 객체를 요청하고 응답받는 HTTP 요청/응답에 1RTT, 파일 전송시간까지 총 2RTT + 파일 전송시간이 소요된다.  
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/894504ac-88ad-46b2-8dee-c3211b93f6c3)

### HTTP와 웹 서버
### 가상 호스트
HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있다.
고객마다 다른 도메인을 가지고 다른 웹사이트를 실행할 수 있게 하기 위해 **가상 호스트(Virtual Host)** 라는 기능을 사용한다.
이를 이용하면 물리적으로는 서버가 1대지만 가상으로 여러 개가 있는 것처럼 설정하는 것이 가능하다.

같은 IP 주소에서 다른 호스트명과 도메인을 가진 여러 개의 여러 웹 사이트가 실행되는 가상 호스트 시스템 때문에, HTTP 리퀘스트에서는 호스트명과 도메인 명을 완전히 포함한 URI를 지정하거나 Host 헤더 필드에서 지정해주어야 한다.

### 통신 중계 프로그램
HTTP는 클라이언트와 서버 이외에 프록시(Proxy), 게이트웨이(Gateway), 터널(Turnel)과 같은 통신을 **중계**하는 프로그램과 서버를 연계하는 것도 가능하다.
이러한 프로그램과 서버는 다음 서버에 리퀘스트를 중계하고, 서버로부터 받은 리스폰스를 클라이언트에 반환한다.<br><br>

#### 프록시
서버와 클라이언트의 양족 역할을 하는 중계 프로그램으로 클라이언트로부터 리퀘스트를 서버에 전송하고, 서버로부터의 리스폰스를 클라이언트에 전송한다.

클라이언트로부터 받은 리퀘스트 URI를 변경하지 않고 그 다음의 리소스를 가지고 있는 서버에 보내며, 리소스 본체를 가진 서버를 **오리진 서버(Origin Server)** 라고 부른다.
오리진 서버로부터 되돌아온 리스폰스는 프록시 서버를 경유해 클라이언트에 돌아온다.

프록시 서버를 여러 대 경우하는 것도 가능하며 중계 시에는 Via 헤더 필드에 경유한 호스트 정보를 추가한다.

캐시를 사용해 네트워크 대역을 효율적으로 사용하고, 조직 내 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 지키려는 목적으로 사용하는 경우가 있다.

프록시는 다음과 같이 캐시 여부와 메시지 변경 여부로 구분된다.

##### 캐싱 프록시(Cashing Proxy)
프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시로, 프록시에 다시 같은 리소스에 리퀘스트가 온 경우 오리진 서버로부터 리소스를 획득하는 것이 아니라 캐시를 리스폰서로서 되돌려 준다.

##### 투명 프록시(Transparent Proxy)
프록시로 리퀘스트와 리스폰스를 중계할 때 메시지 변경을 하지 않는다. 반면 변경을 가하는 타입의 프록시는 비투과 프록시라고 한다.

#### 게이트웨이
다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신하여 경우에 따라서는 클라이언트가 상대가 게이트웨이인 것을 인지하지 못하는 경우도 있다.
동작은 프록시와 유사하나 게이트오ㅞ이의 경우에는 그 다음 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다.
클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안정성을 높이는 역할을 한다.

#### 터널
서로 떨어진 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램으로, SSL과 같은 암호화 통신을 통해 서버와 안전하게 통신하고자 할때, 안전한 통신로를 확립하기 위해 사용한다.
터널은 통신하고 있는 양쪽 끝의 접속이 끊어질 때 종료한다.

### 캐시(Cache)
캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다.
캐시를 이용하면 리소스를 가진 서버에 액세스하는 것을 줄일 수 있으므로 통신량과 통신 시간을 절약할 수 있다.

캐시 서버는 프록시 서버 중 하나로 캐싱 프록시로 분류되며 서버로부터의 리스폰스를 중계하는 시점에 프록시 서버 상에 리소스의 사본을 보존한다.

#### 캐시의 유효성
같은 캐시를 계속해 사용하다보면 오리진 서버에 있는 원래 리소스가 갱신되는 경우에도 낡은 리소스를 그대로 보내게 될 수 있다.
캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효 기간 등에 의해 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를다시 획득하러 가는 경우가 있다.

#### 클라이언트의 캐시
캐시 서버뿐만 아니라 클라이언트가 사용하는 브라우저에서도 캐시를 가질 수 있다.
인터넷 익스플로러에서 클라이언트가 보존하는 캐시를 인터넷 임시 파일이라고 부르며, 브라우저가 유효한 캐시를 가진 경우 서버에 액세스하는 게 아니라 로컬 디스크로부터 불러온다.
캐시 서버와 마찬가지로 리소스가 오래된 것으로 판단된 경우에는 오리진 서버에 유효성을 확인하거나 새로운 리소스를 다시 획득하러 간다.

## HTTPS
HTTP의 약점을 해결하기 위해 HTTPS가 등장. 우선 이를 간단히 정리하면 다음과 같다.    
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/a996b2d0-5f43-470d-9aa0-68a7393d0abc)

HTTP에 암호화나 인증 등의 구조를 더해 기밀성, 데이터 무결성, 인증으로 서비스를 향상시킨 것을 **HTTPS(HTTP Secure)** 라고 부른다.  

여기서 기밀성, 메시지 무결성, 종단점 인증은 운영 보안과 더불어 **안전한 통신** 에 요구되는 특성이며 아래에서 설명하곘음

HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아니며, HTTP 통신을 하는 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체한 형태이다.  
HTTP는 보통 TCP와 직접 통신하지만 SSL을 사용하는 경우에는 HTTP는 SSL과 통신하고, SSL이 TCP와 통신하게 된다.

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/45817eba-00c7-499d-8be4-fd010667dab6)

HTTP가 SSL을 사용하면 HTTPS로서 암호화, 증명서, 완전성 보호를 이용할 수 있게 되며, 이때 SSL은 HTTP와는 독립된 프로토콜이다.

<details>
<summary>SSL와 TLS</summary>
<div markdown="1">
SSL과 TLS 모두 데이터를 암호화하는 통신 프로토콜.
SSL의 향상된 버전이 TLS이며 현재는 TLS가 사용되고 있다.   
SSL과 TLS를 혼용해 부르나 편의상 TLS로 통일하겠음
</div>
</details>

### HTTPS 통신 구조

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/fb786c49-f83e-4b15-b3c3-e11b9fc44cbe)

TLS handshake는 HTTPS 프로토콜을 사용하기 위해 서버와 클라이언트가 수행하는 과정으로 보안 연결에 필요한 암호화 방식 교환, 암호화 키 생성과 TLS 인증서 인증 등이 핵심이다.

**Cipher Suites 교환 및 협상**
클라이언트인 웹 브라우저는 Chrome, Safari, Firefox 등 다양한 브라우저가 존재하고 서버도 Nginx, Apache 등 다양한 환경으로 구성된다.  
각각의 구성 환경에서 제공되는 기능은 다양하기 때문에 우선 클라이언트와 서버에서 사용할 암호화 방식을 선정해야 한다.
이것이 TLS handshake 의 첫번째 역할이며, 클라이언트는 사용 가능한 암호화 방식(Cipher Suites) 를 보내며 서버는 암호화 방식(Cipher Suite)을 선정하여 TLS 인증서를 전송하게 된다.

**인증서 인증**
클라이언트는 서버가 전송한 TLS 인증서를 검증하는 작업이 필요하다.  
신뢰 가능한 보안 연결에 필수적인 작업으로 TLS 인증서 검증을 통해 클라이언트가 통신을 시작할 서버가 신뢰할 수 있는 웹사이트인지 판단한다.
또한 이 과정에서 인증서가 검증이 되었다면 서버의 개인키 역시 확인해야 한다.   
모든 TLS 인증서는 서버의 공개키도 구성되어 있으며 해당 공개키의 쌍인 서버의 개인키가 유효한지 검증 작업도 수행해야 한다.

**Session Key 생성 및 교환**
TLS handshake 의 마지막 작업으로 실제 보안 통신에 사용할 “Session Key” 를 구성하여 교환해야 한다.
Session Key 는 대칭키로 구성된다.
비대칭키는 암호화 복호화 작업에 대해서 리소스 자원이 많이 들게 되므로 대칭키를 사용하여 보다 효율적인 보안 통신을 수행한다.

TLS handshake 에서 키 교환까지 완료되면 서버와 클라이언트는 각각 작업의 완료를 알리며 체크섬을 통해 handshake 과정에서 변조나 손상이 없는지 확인한다.  

여기에 덧붙여 애플리케이션 계층의 데이터를 송신할 때는 MAC(Message Authentication Code)라는 메시지 다이제스트를 덧붙여 변조를 감지하고 완전성 보호를 실현할 수 있다.

## 데이터 기밀성
송신자와 지정된 수신자만이 전송되는 메시지 내용을 이해할 수 있어야 한다. 도청자가 해석할 수 없도록 메시지나 통신을 암호화하는 것 


### 공개키 암호화 방식
SSL에서는 공개키 암호화 방식을 채택하고 있다.

> **대칭키 암호화**   
> 암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키(대칭키) 암호 라고 부른다. 공통키 암호 방식은 상대에게 안전하게 키를 배송하고, 받은 키를 안전하게 보관하는 것이 중요하다.
> 이러한 문제를 해결하기 위해 공개키 암호 방식이 사용된다.

공개키 암호는 서로 다른 두개의 키 페어(비밀키와 공개키)를 사용한다. 암호를 보내는 측이 상대의 공개키를 이용해 암호화를 하고, 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시한다.  
이 방식은 암호를 푸는 비밀키를 통신으로 보낼 일이 없기 때문에 도청에 의해 키를 빼앗길 걱정이 없으며, 암호문과 공개키에서 평문을 구하는 것은 매우 어려운 수학적 특징이 있어 간단하지 않다.

HTTPS는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템이다. 키를 안전하게 교환할 수만 있다면 공개키 암호만을 사용해 통신을 해도 괜찮다고 생각할 수 있으나 공개키 암호는 공통키 암호에 비해 처리 속도가 늦다.  
두 방식의 장점을 살릴 수 있도록 키를 교환하는 곳에는 공개키 암호를 사용하고, 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.

## 데이터 무결성
통신하는 내용이 전송 도중에 변경되지 않았음을 체크섬 기술을 확장해 확인

### 암호화 해시 함수
임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜 주는 함수를 해시함수라고 한다.
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/d24ab842-9222-42c3-bd38-4707835394c1)   
클라이언트가 메시지와 메시지를 암호화 해시 함수를 이용해 해싱한 값을 함께 서버로 전달. 서버는 자신의 암호화 해시함수로 메시지를 해싱한 후 이 값이 클라이언트로부터 받은 값과 동일한지 여부로 데이터의 무결성 판단.

## 통신 상대 인증
송신자와 수신자가 통신에 참여하는 상대방이 실제 누구인지 확인하기 위해 상대방의 신원을 확인하는 것
### 증명서
상대가 정상 서버인지 아닌지를 증명할 수 없다. 이를 해결하기 위해 인증 기관과 인증 기관이 발행하는 공개키 증명서가 이용되고 있다.

인증 기관은 다음과 같이 이용된다.

1. 서버 운영자가 인증 기관에 공개키를 제출한다.
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 암호화해 공개키 인증서에 서명이 끝난 공개키를 담는다.
3. 서버는 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신한다.
4. 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해 서버의 공개키를 신뢰할 수 있다.
5. 인증 기관의 공개키는 안전하게 클라이언트에 전달되어야 한다. 통신 중에는 어려운 문제이므로 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓는다.

조직의 실제성을 증명하는 EV SSL 증명서도 있으며, 클라이언트를 확인하는 클라이언트 증명서도 이용이 가능하다. 그러나 클라이언트 증명서는 증명서의 입수와 배포에 비용이 소모되며, 클라이언트의 실재를 증명할 뿐 사용자의 존재 유무를 증명하는 증명서는 아니라는 문제점이 있다.

SSL은 인증 기관을 신용할 수 있다는 전제로 이루어져 있으며, 독자적으로 구축한 인증 기관을 자기 인증 기관이라 부르고 여기서 발행한 쓸모 없는 증명서를 비하해 ‘나야 나 증명서’라고 부르기도 한다. 마이너 인증 기관을 사용하면 ‘나야 나 증명서’ 가 될 수도 있다.

> **인증서 체인**  
> 엔티티를 인증하는 데 사용되는 인증서 목록이자 경로로, 신뢰 체인은 CA에서 발급한 루트 인증서(Root Certificate)부터 하나 이상의 중간 인증서(Intermediate Certificate) 및 서버 인증서(Leaf Certificate)로 구성되어 있다.     
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/c6e4c5dd-a502-46a4-80db-c1e102a92d5f)  
> **루트 인증서**: 신뢰 체인 모델의 핵심으로 엄격하게 관리되며 중간 인증서를 발급하는데 사용한다. 전송을 통해 관리하기 적절하지 않으므로 루트 저장소에서 관리된다.   
> **중간 인증서**: 서버 인증서와 루트 인증서의 중개자 역할을 한다.  루트 인증서의 손상은 루트 인증서부터 신뢰를 얻는 모든 인증서가 재발급되어야 하는 상황이 생기므로 중간 인증서를 사용하여 최종 사용자에게 서버 인증서를 발급하는 방식으로 보안 수준을 높일 수 있다.   
>  루트 CA가 개인키로 중간 CA의 중간 인증서에 서명하면 중간 인증서는 신뢰할 수 있는 인증서가 되고, 해당 중간 CA 는 중간 인증서로 다른 중간 CA 의 인증서 혹은 최종 서버 인증서에 서명할 수 있게 된다.  
> 이러한 방식을 이용하면 루트 CA 는 오프라인 상태로 중간 CA 의 인증서 발급을 위해서만 사용되므로 루트 CA 의 역할을 분산할 수 있으며 중간 CA 인증서의 문제가 발생한 경우 해당 중간 CA 부터 시작하는 분기의 인증서만 재발급하면 된다.  
> **서버 인증서**: End Entity Certificate 로 평소에 TLS/SSL 인증서로 불리는 인증서이며 개발자가 구매하는 SSL 인증서는 보통 서버 인증서를 의미한다.
> 서버와 사용자 간의 민감한 통신을 보호/암호화할 수 있도록 서버에 설치하는 암호화된 데이터가 포함된 텍스트 파일이며 중간 CA 의 개인키로 암호화된다. 

### 인증서 유효성 검사 프로세스  
1. 브라우저가 홈페이지에 접근하여 인증서 체인을 다운받는다.
2. 브라우저는 다운받은 인증서 체인에 따라 역추적을 시작.
3. 인증서 체인과정(역추적)은 브라우저가 신뢰할 수 있는 기관(루트 CA) 목록의 인증서를 확인할때까지 계속되며, 만약 TLS 인증서의 루트 인증서까지 도달했지만 브라우저가 신뢰할 수 있는 기관의 인증서가 아닌경우 브라우저는 신뢰할 수 없다고 경고.

### TLS 전체 프로세스
웹 서버의 인증서 구성부터 클라이언트에서 인증서 검증까지의 프로세스  

1. 서버는 개인키와 공개키를 생성.
2. 서버는 서버의 공개키와 서버의 정보를 포함한 CSR(인증서 서명 요청)을 생성.
3. CSR 를 통해 중간 CA 에 TLS 인증서 발급을 요청.
4. 중간 CA 는 CSR 에 대한 검증이 끝나면 서버의 공개키를 해시하고 CA 개인키로 서명한 서버 인증서를 구성.
5. 웹 서버는 중간 CA 에서 구성된 서버 인증서를 설치하고 인증서의 신뢰도 보장을 위해 중간 CA 의 중간 인증서까지 설치.
6. 클라이언트가 서버와 연결을 시도하고 TLS handshake 과정 시작.
7. TLS handshake 과정 중 서버는 클라이언트에게 인증서 체인을 전송.
8. 인증서 체인을 전송받은 클라이언트는 루트 저장소에 저장된 신뢰할 수 있는 CA 의 인증서인지 유효성 검사를 시작.
9. 서버로부터 받은 인증서 체인의 루트 인증서가 신뢰할 수 있는 CA 의 인증서로 검증되면 유효성 검사가 종료.

### 단점
SSL을 사용하면 처리가 늦어지게 된다는 단점이 있는데 원인은 다음과 같다.

1. TCP 접속과 HTTP 리퀘스트/리스폰스 이외에 SSL에 필요한 통신이 추가되면서 전체적으로 처리할 통신이 증가하여 통신 속도가 떨어진다.
2. SSL은 반드시 암호화 처리를 하고 있기 때문에 암호화나 복화화를 위한 계산 때문에 CPU나 메모리 등의 리소스를 다량으로 소비한다.

네트워크 부하는 HTTP에 비해 2-100배 느리나, 이를 근본적으로 해결할 방법은 없기 때문에 SSL 엑셀레이터라는 하드웨어를 사용하여 해결하기도 한다.   
이러한 이유로 항상 HTTPS를 사용하지는 않으며 민감한 정보를 포함하지 않는 통신에서는 HTTP를 사용하고, 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다.  
HTTPS를 사용하기 위해서 증명서가 필요하기 떄문에 이러한 비용이 부담되는 서비스나 개인적인 웹 사이트에서는 HTTP만 선택하는 경우도 있다.

# Reference
그림으로 배우는 Http & Network Basic - 우에노 센  
컴퓨터 네트워킹 하향식 접근 - James F. Kuroese, Keith W. Ross  
[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)   
[[10분 테코톡] 헤나의 HTTPS](https://www.youtube.com/watch?v=KpyzbEFYE_E)  
[Certificate Chain](https://dongmin-tech.tistory.com/17)    
[IBM - 인증서 체인이 작동하는 방법](https://www.ibm.com/docs/ko/ibm-mq/7.5?topic=ssfksj-7-5-0-com-ibm-mq-sec-doc-q009880--htm)