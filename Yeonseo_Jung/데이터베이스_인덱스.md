# [1주차] 인덱스
## 인덱스 (index)
데이터베이스 테이블에 저장된 **데이터의 검색 속도를 향상시키기 위한 자료구조**로, 데이터베이스 내의 특정 컬럼(열)이나 컬럼들의 조합에 대한 값과 해당 값이 저장된 레코드(행)의 위치를 매핑하여 데이터베이스 쿼리의 성능을 최적화하는 데 중요한 역할을 한다.

데이터를 검색할 때 전체 테이블을 스캔하는 것이 아니라, 인덱스를 사용하여 검색 대상 레코드의 범위를 줄일 수 있으므로 빠른 속도로 검색이 가능해진다.

`i.g. 책의 목차/색인`

## 동작 과정 
![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/9fbf2e0b-aa70-42df-b71f-f99d46b86de5)
### Full Scan
인덱스가 설정되지 않았을 때 데이터를 검색하는 경우를 의미.  
WHERE절 조건에 맞는 데이터를 찾아내기 위해서 테이블의 레코드를 처음부터 끝까지 다 읽으면서 검색 조건과 맞는지를 비교해야 하므로 가장 느린 Scanning 방법이며, 전체 데이터를 읽는 과정에서 많은 자원을 소모한다.

### 인덱스 스캔
인덱스는 테이블 내에 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성.  
인덱스가 생성되었다면, SELECT 쿼리문에서 'Index 생성 컬럼을 WHERE 조건'으로 걸거나 'Index 컬럼으로 OrderBy에 의한 Sort를 적용'하는 등의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 적용하여 SELECT문이 실행된다.

## 장단점 
### 장점
1. 검색 대상 레코드의 범위를 줄여 검색 속도를 빠르게 할 수 있다.
2. 중복 데이터를 방지하거나 특정 컬럼의 유일성(Unique)을 보장할 수 있다.
3. ORDER BY 절과 GROUP BY 절, WHERE 절 등이 사용되는 작업이 더욱 효율적으로 처리된다.

### 단점
1. 인덱스 생성에 따른 추가적인 저장 공간이 필요하다. (인덱스 사용 시 해당 정보를 담은 MYI 파일 생성)
2. CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다.
3. 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
4. 인덱스 생성 시간이 오래 걸릴 수 있다.

![image](https://github.com/yeondori/SSAFY_CS_Study/assets/93027942/5582c6cb-0564-48c1-992f-0e6e4f3efc71)
그림에서 나타나듯, 인덱스 스캔에서 특정 시점까지는 'Full Table Sacn'이 더 빠를 수 있다.  
Index 스캔은 B+TREE에서 leaf node까지 찾아 내려가서 해당 데이터를 찾기 위해 디스크로 접근하는 과정을 거치는 반면, Full Table Scan은 B+TREE를 거치지 않고 바로 디스크에서 데이터를 읽어오기 때문.

-> 데이터의 양이 많지 않거나, Index가 효율적으로 설정되어 있지 않은 경우는 오히려 Table Full Scan이 더 빠르다


인덱스는 데이터베이스에서 검색 및 처리하는 속도를 향상시키는 데 중요한 역할을 하지만, 인덱스를 적절하게 활용하지 않으면 오히려 데이터베이스의 성능이 저하되거나 저장 공간이 낭비될 수 있다.

-> **인덱스를 적절히 선택하고 생성하는 것이 중요하다.**

## 관리
인덱스는 항상 최신 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 따라서 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로
해주어야 하며, 그에 따른 오버헤드가 발생한다.

- **INSERT** : 새로운 데이터에 대한 인덱스를 추가한다.
- **DELETE** : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
- **UPDATE** : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

-> 데이터 갱신보다는 **조회**에 주요 사용되는 컬럼에 index를 생성하는 것이 바람직

## 인덱스를 사용하는 경우

1. **대량의 데이터를 검색하는 경우**  
   
   대량의 데이터를 전체 스캔하는 것은 매우 느리고 부하가 발생하기 때문에 인덱스를 사용하여 검색하는 것이 효율적이다.  



2. **정렬된 결과를 출력하는 경우**
   
   인덱스를 사용하여 데이터를 정렬하면 매우 빠르게 정렬된 결과를 출력할 수 있다.


3. **조인 연산을 수행하는 경우**
      
   조인 연산을 수행하는 경우 인덱스를 생성하여 조인 대상 테이블의 데이터를 빠르게 검색할 수 있다.


4. **유니크한 값을 가져오는 경우**
   
   인덱스는 유니크한 값을 가지고 있는 필드에 대해 중복되지 않는 값을 빠르게 검색할 수 있다. 


5. 검색 빈도가 높은 경우 

   검색 빈도가 높은 필드에 대해서 인덱스를 생성하여 검색 속도를 향상시키는 것이 좋다. 

## 인덱스 자료구조
### 해시 테이블(Hash table)
해시 테이블은 키(Key)와 해시 값(Hash Value) 쌍으로 이루어진 자료구조이다. O(1)의 시간복잡도를 가지고 있어 상당히 빠른 검색을 할 수 있는 것이 특징이다. 해시 테이블의 검색 방식은 키를 해시
함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아서 검색한다. 해시 테이블은 검색 속도가 매우 빠르지만, 데이터의 분포에 따라 충돌이 발생할 수 있다. 따라서 충돌을 해결하기 위한
방법이 필요하다. 또한, 해시는 등호(=) 연산에만 특화되어 있어 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

### B-Tree
B-Tree는 데이터베이스에서 가장 널리 사용되는 인덱스 자료구조 중 하나이다.
O(logN)의 시간 복잡도를 가지고 있다. 
B-Tree는 균형 잡힌 이진 검색 트리로 데이터베이스에서 검색 속도를 높이기 위해 사용된다. 
B-Tree의 각 노드 내 데이터들은 항상 정렬된 상태인 것이 특징이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다. (자식 노드의 개수는 n+1개)
또한, 한 노드에서 여러 개의 키를 가질 수 있고, 키에 해당하는 데이터도 함께
갖고 있다.

### B+Tree 
B+Tree는 B-Tree의 변형된 구조로 B-Tree와 비슷하지만 몇 가지 차이점을 가지고 있다.
B+Tree 또한 균형 잡힌 이진 검색 트리이다. 
B+Tree는 B-Tree에 비해 더 많은 키를 가질 수 있다.
B+Tree는 B-Tree와 달리 내부 노드(Internal node)와 단말 노드(Leaf node)로 구분된다. 
B+Tree의 모든 데이터는 단말 노드에서만 저장되며, 내부 노드에는 검색을 위한 인덱스만 저장된다. 
모든 리프 노드가 연결 리스트로 연결되어 있으며, 순차적으로 저장되어 있다.
이러한 특징으로 인해 범위 검색(Range Search)이나 순차 검색(Sequential Search)에 효율적이다.

# Reference
https://wildeveloperetrain.tistory.com/131 [DB 데이터베이스 인덱스(Index) 기본 개념과 설명]  
https://ittrue.tistory.com/331 [IT is True:티스토리]