# [1주차] 네트워크
## 웹 통신의 큰 흐름
https://www.google.com/ 를 검색한다고 했을 때 흐름은 다음과 같다.

1. 입력받은 주소를 **DNS** 서버에 조회하여 대응하는 **IP**와 **PORT**를 찾아낸다.
2. 웹 브라우저가 **HTTP** 요청 **메시지**를 생성한다. HTTP 요청 메시지는 메소드와 쿼리, HTTP 버전 정보와 호스트 정보 등으로 구성되어 있다.
3. SOCKET 라이브러리를 통해 TCP/IP 계층과 연결한 뒤, 데이터를 전달한다.
4. **TCP/IP** 패킷 생성, 이때 TCP/IP에는 출발지/목적지의 IP와 PORT, 그리고 전송 데이터인 HTTP 메시지가 포함된다.
5. 요청 패킷을 구글 서버에게 전달한다.
6. 패킷을 받은 구글 서버는 메시지를 보고 해당하는 데이터를 찾아 응답 메시지를 생성한다. HTTP 응답 메시지는 HTTP 버전과 상태 코드, Content-Type(컨텐츠 형식), Content-length 등을 포함한다.
7. 응답 메시지가 포함된 응답 패킷을 웹 브라우저에게 전달한다.
8. 웹 브라우저에 응답 패킷이 도착하면 HTTP 메시지를 렌더링한다. 우리는 렌더링된 결과를 본다.

### IP
지정한 IP 주소에 데이터를 전달할 수 있도록 하는 규칙이며 패킷(Packet)이라는 통신 단위로 데이터가 전달된다.   
클라이언트는 전송하고자 하는 데이터를 출발지 IP와 목적지 IP를 포함해 IP 패킷에 담아 서버에게 전달하고, 패킷을 전달받은 서버는 동일한 방식으로 OK 패킷을 클라이언트에게 전달한다.   
그러나 이러한 방식만으로는 다음과 같은 한계가 있다.

#### 비연결성
패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송할 수 있다.
#### 비신뢰성
중간에 패킷이 사라지거나 패킷이 순서대로 도착하지 않는 경우가 발생할 수 있다.
#### 프로그램 구분
같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 수 있다.

이러한 문제를 해결해주는 것이 TCP이다.

### TCP
TCP는 전송 제어 프로토콜(Transmission Control Protocol)로 신뢰할 수 있는 프로토콜이며, IP 패킷 안에 출발지 port, 목적지 port, 전송 제어, 순서 검증 정보 등 TCP 관련 정보가 추가된다.  
현재는 대부분의 애플리케이션에서 TCP를 사용한다. TCP는 다음과 같은 특징이 있다.

#### 연결지향 - TCP 3 way handshake (가상 연결)
TCP 3 way handshake는 
1. 클라이언트에서 서버로 SYN(접속 요청)
2. 서버에서 클라이언트로 SYN + ACK(요청 수락)
3. 클라이언트가 서버로 ACK 

의 세 번의 메시지 전달 과정으로 연결이 된다. 그러나 이때의 연결은 물리적인 연결이 아닌 논리적인 가상 연결이다.   

이러한 방식으로 연결이 된 후에야 데이터를 전송하기 때문에 연결이 없는 상태에서는 패킷을 전송하지 않는다. 
참고로 현재는 최적화되어 3번 ACK와 함께 데이터 전송이 가능하다.

#### 데이터 전달 보증
TCP에서는 데이터를 전송하면 서버에서 데이터를 받은 경우 이를 알려준다. 따라서 만약 요청이 전송되었는데 서버에서 응답이 없다면, 메시지가 전달 도중 누락이 되었다고 알 수 있게 된다.

#### 순서 보장
클라이언트에서 보낸 순서대로 패킷이 오지 않은 경우, 서버에서는 순서가 잘못된 부분부터 패킷을 다시 요청한다.

### PORT
만약 하나의 클라이언트에서 한번에 둘 이상을 연결해야 한다면 어떨까? 여러 서버에서 오는 패킷을 어떻게 구분할까? 앞선 TCP 설명에서 TCP/IP 패킷에는 출발지/목적지의 IP뿐만 아니라 PORT가 포함되어 있다.   

IP는 목적지 서버를 찾는 것이라면, PORT는 해당 서버에서 돌아가는 애플리케이션을 구분하는 것, 즉, IP 내에서 프로세스를 구분해주는 것이라고 생각하면 된다.  
0 ~ 65535에 할당이 가능한데, 0 ~ 1023은 잘 알려진 포트로, 사용하지 않는 것이 좋다. 참고로 FTP(20,21), TELNET(23), HTTP(80), HTTPS(443)을 사용한다.

### DNS
IP는 기억하기 매우 어려우며 변경될 수 있다. DNS(Domain Name System)은 이 두 가지 문제를 해결해주는 시스템으로, DNS 서버는 도메인 명을 IP주소로 변환하고, 변경되는 IP주소도 관리해준다. 
전화번호부라고 생각하면 이해가 쉽다.

### HTTP
하이퍼텍스트를 전송하는 프로토콜으로 HTML, TEXT뿐만 아니라 이미지, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터가 전송 가능하며 서버 간 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.   
HTTP/1.1, HTTP/2는 TCP 기반, HTTP/3은 UDP 기반이며 현재는 HTTP/1.1을 주로 사용한다.

HTTP는 클라이언트 서버 구조로, 클라이언트는 서버에 요청 후 응답을 받고 동작한다. 
항상 같은 서버가 유지되어야 하는 Stateful(상태 유지)과 달리 Stateless(무상태)는 응답 서버를 쉽게 바꿀 수 있어 서버 장애 시 빠른 대응과 무한한 서버 증식(스케일 아웃)이 가능하다.   

그러나, 모든 것을 무상태로 설계할 수 있지는 않다. 무상태의 경우 전송되는 데이터량이 비교적 많고, 로그인과 같은 경우는 상태 유지가 필요하다. 이러한 경우 브라우저 쿠키나 서버 세션을 사용해 상태를 유지하는데, 결론적으로 웹 애플리케이션 설계 시에는 최소한의 상태 유지를 사용하는 것이 좋다.  

HTTP는 기본적으로 연결을 유지하지 않는 모델으로, 클라이언트의 요청에 응답 후 연결을 끊어 서버 자원을 효율적으로 사용한다. 즉. 클라이언트와 서버가 요청과 응답을 주고받으면 연결이 끊어지고, 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다. 그러나 이러한 방식은 TCP/IP 연결을 매번 새로 맺어야 하므로 비교적 시간이 소요되며, 웹 브라우저로 사이트 요청 시에는 매번 수많은 자원들이 다운로드되는 한계가 있어 지속 연결(Persistent Connections) 을 사용한다.

HTTP 메시지 구조를 정리하면 다음과 같이 단순하며 확장 가능하다.
![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/d6e38e3a-fcfd-4792-8119-759a87119d00)


### Reference 
인프런 강의 [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)