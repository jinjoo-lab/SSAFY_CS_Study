# HTTP란?

HTTP(HyperText Transfer Protocol)HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. HTTP는 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.즉, HTML과 같은 문서를 전송하기 위해 사용되며 OSI 7 계층에서 응용 계층에 있는 프로토콜이다.HTTP는 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며, 전통적인 클라이언트-서버 아키텍처 모델에서 클라이언트가 HTTP 메시지 양식에 맞춰 요청을 보내면, 이에 서버는 HTTP 메시지 양식에 맞춰 응답을 한다.HTTP는 특정 상태를 유지하지 않는 무상태성(Stateless)이 특징이다.

## 비지속 연결 & 지속연결

비지속 연결이란 각가의 request/response 쌍이 분리된 TCP연결을 통해 보내지는 것을 의미하고 반면 지속 연결은 같은 TCP 연결상으로 보내는 것을 의미한다.

### 비지속 연결 예시

ex)

1. **HTTP** 클라이언트는 **HTTP**의 기본 포트 번호 **80**을 통해 [www.someschool.edu](http://www.someschool.edu/)  서버로 **TCP** 연결을 시도한다. **TCP** 연결과 관련하여 클라이언트와 서버에 각각 소켓이 있게 된다.
2. **HTTP** 클라이언트는 **1**단계에서 설정된 **TCP** 연결 소켓을 통해 서버로 **HTTP** 요청 메시지를 보낸다. 이 요청 메시지는 /someDepartment/home.index 경로 이름을 포함한다.
3. **HTTP** 서버는 1단계에서 설정된 연결 소켓을 통하여 요청 메시지를 받는다. 저장장치로부터 /someDepartment/home.index 객체를 추출한다. **HTTP** 응답 메시지에 그 객체를 캡슐화한다. 그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다.
4. **HTTP** 서버는 **TCP**에게 연결을 끊으라고 한다.(그러나 실제로 **TCP** 클라이언트가 응답 메시지를 올바로 받을 때까지 연결을 끊지 않는다.)
5. **HTTP** 클라이언트가 응답 메시지를 받으면, **TCP** 연결이 중단된다. 메시지는 캡슐화된 객체가 **HTML** 파일인 것을 나타낸다. 클라이언트는 응답 메시지로부터 파일을 추출하고 **HTML** 파일을 조사하고 **10**개의 **JPEG** 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 **JPEG** 객체에 대하여 처음 네 단계를 반복한다.

**앞 단계에서 서버는 객체를 보낸 후에 각 TCP 연결이 끊어지므로 비지속 연결을 사용하고 있습니다**(연결이 다른 객체를 위해 유지되지 않음). 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송합니다. **그래서 이 예에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결이 만들어집니다.**

클라이언트가 기본 HTML 파일을 요청하고 그 파일이 클라이언트로 수신될 때까지의 시간을 측정해 봅시다. **이를 위해서 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간이 RTT(round trip time)을 정의합니다.**

### 지속연결

**비지속 연결 단점**

**첫째**, 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 합니다.

- **TCP** 버퍼가 할당되어야 하고 **TCP** 변수들이 클라이언트와 서버 양쪽에 유지되어야 합니다.
- 이는 수많은 다른 클라이언트의 요청을 동시에 서비스하는 웹 서버에게 심각한 부담을 줄 수 있습니다.

**둘째**, 앞서 언급한 대로 각 객체는 **2 RTT**를 필요로 했습니다.

- **TCP** 연결 설정에 **1 RTT**
- 객체를 요청하고 받는데 **1 RTT**

**HTTP1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지합니다.**

- 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내집니다.
- 특히, 전체 웹 페이지(앞 예에서 기본 **HTML** 파일과 10개 이미지)를 하나의 지속 **TCP** 연결을 통해 보낼 수 있습니다.
- 또한 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 **TCP** 연결을 통해 보낼 수 있습니다.
- 이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있습니다.**(파이프라이닝)**

일반적으로 **HTTP** 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫습니다. 서버가 연속된 요구를 수신할 때, 서버는 객체를 연속해서 보냅니다. **HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용합니다.**

최근에, **HTTP/2**와 같은 연결상에서 **다중 요청(request)**과 **응답(reply)**이 가능하고 이 연결 내에서 **HTTP** 메시지 요청과 응답의 우선순위 기법이 가능하도록 **HTTP1.1**을 기반으로 제안되었습니다.

### *TCP 세그먼트*

![http1](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/23d1780f-d9a5-491d-93ec-e5002acaa115)

HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냅니다. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달합니다.

### **TCP 커넥션 유지하기**

컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있습니다. 각각의 TCP 커넥션을 유지하기 위해 **<발신지 IP 주소, 발신지 포트 번호, 수신지 IP 주소, 수신지 포트 번호>** 로 구성된 4개의 값이 필요합니다. 이를 **4-tuple** 이라고 합니다. 4개의 값 중 일부는 같을 수 있지만, 4가지가 모두 같은 서로 다른 TCP 커넥션은 존재할 수 없습니다.

## **순차적인 트랜잭션 처리에 의한 지연**

*4개의 트랜잭션 (순차)*

![http2](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/6f5016b3-0c47-48a3-8d6c-19b8bf80881d)

예를 들어 3개의 이미지가 있는 웹 페이지가 있다고 하겠습니다. 브라우저가 이 페이지를 보여주려면 4개의 HTTP 트랜잭션을 만들어야 합니다. 하나는 해당 HTML을 받기 위해, 나머지 3개는 첨부된 이미지를 받기 위한 것입니다. 각 트랜잭션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것입니다.

사용자에게 순차적으로 이미지가 하나씩 보여질 것입니다. 하나의 이미지를 내려받고 있는 중에는 웹 페이지의 나머지 공간에 아무런 변화가 없어서 느껴지는 심리적인 지연도 가중됩니다. 설령 순차적으로 보여지는 것이 결과적으로 더 빠를지라도, 한 번에 모든 이미지를 보여주는 것이 사용자들은 더 빠르다고 느낍니다.

이런 문제점을 막기 위해 HTTP 커넥션의 성능을 향상시킬 수 있는 여러 기술이 있습니다. 이 기술들 중 **`병렬 커넥션`**, **`지속 커넥션`**, **`파이프라인 커넥션`**을 알아보겠습니다.

## **병렬(parallel) 커넥션**

*병렬 트랜잭션*

![http3](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/144c5a7e-8bb4-4a7a-85c0-34618fa68f8c)

병렬 커넥션은 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 하는 방법입니다. 위의 예에서는 3개의 이미지를 할당받은 각 TCP 커넥션상의 트랜잭션을 통해 병렬로 내려받습니다.

### **병렬 커넥션은 페이지를 더 빠르게 내려받는다**

단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이지를 더 빠르게 내려받을 수 있습니다. 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 나려받는 데에 남은 대역폭을 사용할 수 있습니다.

### **병렬 커넥션이 항상 더 빠르지는 않다**

병렬 커넥션이 일반적으로 더 빠르기는 하지만, 항상 그렇지는 않습니다. 클라이언트의 네트워크 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는 데에만 쓸 것입니다. 여러 개의 객체를 병렬로 내려받는 경우, 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어집니다.

### **병렬 커넥션은 더 빠르게 "느껴질 수" 있습니다**

결과적으로 모든 내용이 다 로드되기까지의 시간이 더 걸러더라도, 화면의 내용이 한 번에 로드되는 것을 더 빠르다고 느낍니다. 따라서 병렬 커넥션이 페이지를 더 빠르게 내려받는 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있습니다.

## **지속(persistent) 커넥션**

*지속 커넥션*

![http4](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/db6f8e0c-ad11-4e6f-857b-d47a1e586988)

웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺습니다. 예를 들어 웹 페이지에 첨부된 이미지들 대부분은 같은 웹 사이트에 있고, 상당수의 하이퍼링크도 같은 사이트를 가리킵니다. 따라서 HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있습니다. 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부릅니다. 해당 서버에 이미 맺어져 있는 지속 커넥션을 재사용함으로써, 커넥션을 맺기 위한 준비 작업에 이르는 시간을 절약할 수 있습니다.

### **지속 커넥션 VS 병렬 커넥션**

병렬 커넥션은 앞서 봤듯이 여러 객체가 있는 페이지를 더 빠르게 전송합니다. 하지만 병렬 커넥션에는 몇 가지 단점이 있습니다.

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요됩니다.
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어집니다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있습니다.

지속 커넥션은 병렬 커넥션에 비해 몇 가지 장점이 있습니다. 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 커넥션의 수를 줄여줍니다. 하지만 지속 커넥션을 잘못 관리할 경우, 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 됩니다.

그래서 지속 커넥션은 병렬 커넥션과 함께 사용될 때에 가장 효과적입니다. 그래서 오늘날 많은 웹 애플리케이션은 적은 수의 병렬 커넥션만을 맺고 이를 유지합니다.

## **파이프라인(pipelined) 커넥션**

*파이프라인 커넥션*

![http5](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/1f279877-922e-47fc-896b-288b97431f4b)

HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있습니다. 하지만 파이프라인에는 여러 가지 제약 사항이 있습니다.

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안됩니다.
- HTTP 응답은 요청 순서와 같게 와야 합니다. HTTP 메시지는 순번이 있지 않기 때문에, 응답이 순서 없이 오면 순서에 맞게 정렬시킬 수 없습니다.
- HTTP 클라이언트는 커넥션이 언제 끊어져도 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 수 있어야합니다. 예를 들어, 클라이언트가 지속 커넥션을 맺고 10개의 요청을 보낸다고 하더라도 서버는 5개의 요청만 처리하고 커넥션을 끊어버릴 수 있습니다. 남은 5개의 요청은 실패할 것이고 클라이언트는 커넥션을 다시 맺고 요청을 보낼 수 있어야 합니다.
- HTTP 클라이언트는 POST 요청과 같은 멱등성이 보장되지 않는 요청은 파이프라인을 통해 보내면 안됩니다. 왜냐하면 에러가 발생하면 파이프라인을 통한 요청 중에 어떤 것들이 서버에서 처리되었는지 클라이언트는 알 수 없기 때문입니다.

## HTTP 메서드

<img width="1000" alt="http6" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/cde424de-7f1c-4f0d-98ad-512790120650">

- **HTTP 메소드의 대표격인 GET과 POST 비교**

**A. GET**

우선 GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url 에 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다.(이것이 parameter) 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)

**B. POST**

POST 방식의 request 는 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만하다.)

**C. 실제 사용 예시**

GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다고 볼 수 있는 것이다.

반면에 POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

부수적인 차이점을 좀 더 살펴보자면 GET 방식의 요청은 브라우저에서 Caching(일종의 임시 저장)할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.

**D. HEAD**

정확히 GET과 같지만, 서버는 응답으로 엔터티 본문 반환없이 헤더만을 반환. 클라이언트는 리소스를 가져올 필요 없이 헤더만을 통해 정보를 얻을 수 있다.

**E. PUT**

서버가 요청의 본문을 갖고 요청 URI의 이름대로 새 문서를 만들거나, 이미 URI가 존재한다면 요청 본문을 변경할 때 사용합니다. ( 수정 )

**F. DELETE**

서버에서 요청 URI 리소스를 삭제하도록 요청합니다. ( 삭제 ) 클라이언트는 항상 삭제된다고 생각하지만, 서버에서는 이 요청을 무시할 수도 있다.(Soft Delete의 경우)

**G. TRACE**

클라이언트와 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지의 이상 유무를 파악한다. 서버는 응답 메시지의 본문에 자신이 받은 요청메시지를 넣어 응답하며, 주로 진단을 위해 사용.

**H. OPTIONS**

서버에게 특정 리소스가 어떤 메소드를 지원하는지 물어볼 수 있습니다.

<img width="1000" alt="http7" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/7ef10704-9465-4431-ac57-c6affb6e04c0">

- **응답 상태코드**
- 100 - 109
    - 메시지 정보
- 200 - 206
    - 요청 성공
- 300 - 305
    - 리다이렉션
- 400 - 415
    - 클라이언트 에러
- 500 - 505
    - 서버에러

API 개발 시 올바른 상태코드를 응답하는 것은 매우 중요하다. 예를 들어, 사용자가 요청 파라미터를 잘못 입력한 경우,  잘못된 파라미터로 인해 비즈니스 로직에서 에러가 발생했다고하여, 500 코드를 반환하면 안된다. 사용자가 잘못 입력한 경우이므로, 이 때는 403 코드를 반환해야 한다.

## URL이란?

URL은 Uniform Resource Locators의 약자로, 웹에서 HTML 페이지, CSS 문서, 이미지 등 리소스의 위치를 나타내는 주소를 뜻한다.

쉽게 말해서, URL은 웹 페이지를 찾기위한 주소를 말한다. 흔히 웹 사이트 주소로 알고 있지만, URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있다. 그 주소에 접속하려면 해당 URL에 맞는 프로토콜을 알아야 하고, 그와 동일한 프로토콜로 접속해야 한다.

## URL의 구조

URL은 보통 Scheme, Domain Name, Port, Path, Parameter, Anchor로 이루어져 있다.

![http8](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/01dcc90c-1e63-4374-a275-c758a60effad)

### Scheme(=Protocol)

브라우저가 리소스를 요청하기 위해 사용해야 하는 프로토콜을 나타낸다.

프로토콜은 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약으로, 웹에서는 브라우저와 서버 간에 데이터를 주고 받기 위한 방식으로 `HTTPS`/`HTTP` 프로토콜이 가장 많이 사용되고 있다. `HTTPS`/`HTTP` 외에도 `mailto:`(이메일 주소를 지정하는 프로토콜), `ftp:`(파일을 주고 받는 프로토콜) 등 다양한 프로토콜이 존재한다.

- HTTP(Hyper Text Transfer Protocol): 웹 브라우저와 웹 서버가 서로 데이터를 주고받기 위해 만든 통신규약
- HTTPS(Hyper Text Transter Protocol Secure): HTTP에서 보안이 강화된 버전

> http://www.liankim.com
> 
> 
> https**:**//www.liankim.com
> 
> ftp**:**//192.23.56.189
> 

### Domain Name

도메인(Domain)은 IP 주소를 갖는 서버를 사용자가 쉽게 기억하고 찾을 수 있도록 만들어준 서비스이다. 실제 컴퓨터와의 통신에서는 숫자로 표현된 주소(=IP)를 사용하기 때문에 이를 변환시켜 줄 네임 서버가 필요하다.

### Port

포트 번호를 통해 어떤 서버를 이용할지 결정하며, `:` (콜론) 뒤에 나온다. 웹 서버가 HTTP 프로토콜의 표준 포트(HTTP의 경우 80, HTTPS의 경우 443)를 사용하는 경우 일반적으로 생략되기 때문에, URL에는 기본적으로 표준 포트번호가 생략되어 있는 것이다.

> https://www.google.co.kr:443
> 
> 
> http**:**//www.google.co.kr:80
> 

### Path

파일의 경로를 가리키며, `/` (슬래시) 뒤에 나온다. 폴더 내에 파일과 폴더를 계속 만들 수 있는 것처럼 컴퓨터의 폴더와 비슷한 개념으로 생각하면 이해가 쉽다.

> https://google.com/search/howsearchworks
> 
> 
> https**:**//www.youtube.com/feed/library
> 

### Parameter

파라미터는 쿼리 스트링이라고도 부르며, key(파라미터의 이름)=value(파라미터의 값) 형태로 이루어진다. `?`(물음표) 뒤에 나열되고, `&`기호로 구분되어 여러개가 존재할 수 있다.

광고 분석시 많이 사용되는 UTM(Urchin Tracking Module)이 query parameter를 이용한 사용자 추적 서비스이다.

> https://section.blog.naver.com/BlogHome.naver?directoryNo=0&currentPage=1&groupId=0
> 
- directoryNo=0
- currentPage=1
- groupId=0

### Anchor(=Fragment)

프래그먼트(Fragment), 해시태그(Hashtag)라고도 부르며, 특정 요소를 지시할 수 있다.

예를 들어, 해시태그로 이동을 원하는 요소의 id를 링크로 연결하면 스크롤 이동없이 바로 해당 위치로 이동한다. 파일 디렉토리 및 파일 이름과 유사한 역할로 쓰이는 경우도 있다.

> https://www.naver.com/#wrap
> 

## HTTP 구조

HTTP 헤더와 본문으로 구성되어 있다. HTTP 본문에는 실제로 통신과정에서 주고 받을 컨텐츠가 담겨져 있다.

HTTP헤더는 HTTP메시지(요청/응답)와 본문에 대한 정보를 말해주고 있다. 이에 대해서 이해하는 것이 실제로 중요하다. 해당 메시지가 제공하는 기능에 대한 최소한의 정보가 정리된 요약본이라고 할 수 있기 때문이다. 헤더에 그 프로토콜에 불필요한 내용을 담으면 네트워크로 전송되는 데이터의 크기가 커져서 빠른 전송이 불가능하기 때문에 프로토콜을 설계할 때부터 꼭 필요한 내용만 담아야 하고, 모든 기능이 표현되어야 한다.

이에 대해 HTTP 헤더는 크게 세가지로 구성되어 있다.

<img width="1000" alt="http9" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/9102f5ae-fe07-4e87-8bc8-f5019075e25a">

### General Header

공통 헤더는 요청 및 응답의 메시지 모두에서 사용되지만 **컨텐츠에는 적용되지 않는 헤더**이다.

흔하게 우리가 사용하는 공통 헤더는 `Date`, `Cache-Control`, `Connection`등이 있다.

자세한 내용은 [공통 헤더 파트](https://wonit.tistory.com/309?category=749910)에서 확인할 수 있다.

### Request Header

요청 헤더는 HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더이다.

보통 Fetch될 리소스나 클라이언트 자체에 대한 정보를 포함하여 서버로 보내진다.

자세한 내용은 [요청 헤더 파트](https://wonit.tistory.com/310?category=749910)에서 확인할 수 있다.

### Response Header

위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더이다.

자세한 내용은 [응답 헤더 파트](https://wonit.tistory.com/311?category=749910)에서 확인할 수 있다.

### Entity Header

컨텐츠 길이나 MIME 타입과 같이 Entity Body에 대한 자세한 정보를 포함하는 헤더이다.