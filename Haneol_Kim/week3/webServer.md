## 웹의 구성요소

프록시, 캐시, 게이트웨이, 터널, 에이전트

# 프록시

프록시란 클라이언트와 서버 사이에 위치하여 그들 사이의 HTTP 메시지를 정리하는 중재인이다. 즉, 클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 중간에 대신 전달해주는 서버를 의미한다. 프록시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 한다. 프록시는 클라이언트 요청을 받고 반드시 웹 서버처럼 요청과 커넥션을 다루고 응답을 돌려줘야 한다. 동시에 요청을 서버로 보내기도 하므로, 요청을 보내고 응답을 받는 클라이언트처럼 동작해야 한다.

![web1](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/250815c6-e6f1-444a-9840-d7780a23bd9e)

## 1-1. 프록시 서버를 이용한 데이터 통신 과정

1. **클라이언트에서 프록시 서버로 전달할 요청을 보낸다.**
2. **프록시 서버는 클라이언트로부터 전달 받은 요청을 서버에 요청한다.**
3. **서버는 요청에 맞게 데이터를 프록시 서버로 전달한다.**
4. **프록시 서버는 서버로부터 전달 받은 데이터를 클라이언트에 전달한다.**

# 2. 프록시의 두 종류

## 2-1. 포워드 프록시(Forward Proxy)

![web2](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/726bebe7-b22b-4ae3-9763-179816484a2a)

포워드 프록시 서버는 위 그림처럼 **클라이언트 바로 뒤에** 놓여 있다.

클라이언트가 웹 리소스에 대한 액세스를 요청하면 대상 서버로 직접 요청하는 대신 포워드 프록시 서버로 요청을 보냅니다. 그런 다음 정방향 프록시는 요청을 대상 서버로 전달하고 응답을 수신하여 클라이언트로 다시 보냅니다. 클라이언트는 실제 서버의 신원을 인식하지 못합니다.

Forward Proxy는 내부망에서 **클라이언트와 Proxy 서버가 통신**하여 인터넷을 통해 외부에서 데이터를 가져온다.

**포워드 프록시 예)**

1. 클라이언트에서 www.example.com과 같은 웹사이트에 요청을 보냅니다.
2. www.example.com으로 직접 요청을 보내는 대신 클라이언트가 포워드 프록시 서버로 요청을 보냅니다.
3. 포워드 프록시 서버는 요청을 실제서버(www.example.com)에게 전달합니다.
4. 실제서버는 포워드 프록시 서버에게 응답을 다시 보냅니다.
5. 응답을 받은 포워드 프록시 서버는 이를 클라이언트에게 전달합니다.

## 2-1-1. 포워드 프록시의 장단점

장점

- **클라이언트 보안 (Security)****
- 보통 정부, 학교, 기업 등과 같은 기관은 해당 기관에 속한 사람들의 제한적인 인터넷 사용을 위해 방화벽을 사용한다. 포워드 프록시 서버는 방화벽과 같은 개념으로 제한을 위해 사용 된다고 보면 된다. 즉, 해당 기관에 속한 사람들이 그들이 방문하고자 하는 웹사이트에 직접적으로(directly) 방문하는 것을 방지할 수 있다. 예를 들어, 포워드 프록시 서버에 룰을 추가해서 특정 사이트에 접속하는 것을 막을 수 있다.
- **캐싱 (Caching)****
- 우리가 어떤 웹 페이지에 접근하면 프록시 서버는 해당 페이지 서버의 정보를 캐싱(임시보관)해둔다. 그래서 똑같이 해당 페이지에 접근하거나, 다른 클라이언트가 해당 페이지를 요청할 때 , 캐시된 정보(페이지)를 그대로 반환할 수 있고, 이는 서버의 부하를 줄이는 효과도 낼 수 있다. 만일 4명의 클라이언트가 www.example.com에 접근할때 본래는 각각 따로 인터넷을 경유해서 페이지를 받겠지만, 포워드 프록시를 이용하면 프록시내 캐싱 된 페이지를 불러오기 때문에 훨씬 빠르게 조회할수 있는 원리이다.

### 단점

**단일 실패 지점**

- 포워드 프록시 서버가 다운되면 이를 사용하는 모든 사용자의 인터넷 액세스가 중단되어 가동 중지 시간이 발생할 수 있습니다.

**성능 오버헤드**

- 포워드 프록시를 사용하면 모든 요청과 응답이 이를 통과해야 하므로 성능 오버헤드가 발생할 수 있습니다. 이로 인해 특히 프록시 서버의 전력이 부족하거나 과부하된 경우 지연 시간이 발생할 수 있습니다.

## 2-2. 리버스 프록시(Reverse Proxy)

![web3 (2)](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/fd2f1384-1691-4dde-95a6-92273950db45)

리버스 프록시는 위 그림 처럼 **웹서버 or WAS 앞에 놓여 있는 것**을 말한다.

클라이언트는 웹서비스에 접근할때 웹서버에 요청하는 것이 아닌, 프록시로 요청하게 되고, 프록시가 배후(reverse)의 서버로부터 데이터를 가져오는 방식이다.

클라이언트쪽으로 데이터(response)를 밀어주는게 **포워드**라면, 그 반대편인 서버 쪽으로 데이터(request)를 밀어주는 것이 **리버스 프록시** 라고 보면 된다.

Reverse Proxy는 내부망에서 **Proxy 서버와 내부망서버가 통신**하여 인터넷을 통해 요청이 들어오면 Proxy 서버가 받아 응답해준다.

리버스 프록시 예)

1. 사용자가 www.example.com을 요청합니다.
2. 요청이 리버스 프록시 서버로 이동합니다.
3. 리버스 프록시 서버는 로드, 위치 또는 기타 요소를 기반으로 요청을 처리해야 하는 백엔드 웹 서버를 결정합니다.
4. 선택한 백엔드 서버로 요청을 전달합니다.
5. 백엔드 서버는 요청을 처리하고 응답을 리버스 프록시로 다시 보냅니다.
6. 그러면 리버스 프록시가 사용자에게 응답을 보냅니다.

## 2-2-1. 리버스 프록시의 장단점

장점

**로드 밸런싱 (Load Balancing)**

- 유명한 웹 사이트는 하루에도 수백만명이 방문한다. 그리고 그러한 대량의 트래픽을 하나의 싱글 서버로 감당해 내기란 어렵다. 하지만 리버스 프록시 서버를 여러개의 본 서버들 앞에 두면 특정 서버가 과부화 되지 않게 로드밸런싱이 가능하다.

**서버 보안 (Security)**

- 리버스 프록시를 사용하면 서버 측 보안에 좋다. 리버스 프록시를 사용하면 본래 서버의 IP 주소를 노출시키지 않을 수 있다. 따라서 해커들의 DDoS 공격과 같은 공격을 막는데 유용하다. 클라이언트는 인터넷을 통해 리버스 프록시 서버 url에게 요청을 한다. 그리고 리버스 프록시는 본서버에게 요청을 경유해서 보내게 된다. 이렇게 되면 클라이언트는 본 서버의 url을 모른채 리버스 프록시 url을 통해 서비스를 이용하게 되고, 이는 즉 본서버의 정보를 숨기는 효과가 된다.

**캐싱 (Caching)**

- 만약 어떤 한국에 있는 유저가 미국에 웹서버를 두고 있는 사이트에 접속할때, 리버스 프록시 서버가 한국에 있다고 해보자. 그러면 한국에 있는 유저는 한국에 있는 리버스 프록시 서버와 통신해서 리버스 프록시 서버에 캐싱되어 있는 데이터를 사용할 경우에는 더 빠른 성능을 보여줄수 있다. 포워드 프록시의 캐싱과 비슷한 기능을 한다고 보면 된다. (정확히 프록시의 본래 기능)

**암호화 (Encryption)**

- SSL 암호화에도 좋다. 본래 서버가 클라이언트들과 통신을 할때 SSL(or TSL)로 암호화, 복호화를 할 경우 비용이 많이 들게 된다. 그러나 리버스 프록시를 사용하면 들어오는 요청을 모두 복호화하고 나가는 응답을 암호화해주므로 클라이언트와 안전한 통신을 할수 있으며 본래 서버의 부담을 줄여줄 수 있다.

단점

**단일 실패 지점**

- 리버스 프록시 자체를 사용할 수 없게 되면 모든 클라이언트의 백엔드 서버에 대한 액세스가 중단되어 잠재적으로 가동 중지 시간이 발생할 수 있습니다.

**복잡성**

- 리버스 프록시를 구현하고 관리하는 것은 특히 여러 백엔드 서버가 있는 환경에서 복잡할 수 있습니다. 구성이 잘못되면 서비스가 중단될 수 있습니다.

**리소스 집약적**

- 리버스 프록시는 특히 트래픽이 많은 환경에서 들어오는 트래픽을 처리하기 위해 리소스(하드웨어 및 소프트웨어)가 필요하므로 인프라 비용이 추가될 수 있습니다.

참고 : [https://velog.io/@illi0n/프록시proxy란](https://velog.io/@illi0n/%ED%94%84%EB%A1%9D%EC%8B%9Cproxy%EB%9E%80)

## 웹 캐시란?

자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치로, 웹 요청이 캐시에 도착했을 때 캐시된 로컬 사본이 존재한다면, 원 서버가 아니라 캐시로부터 제공된다.

## 웹 캐시의 혜택

- 불필요한 데이터 전송을 줄여서 네트워크 비용을 줄여준다.
- 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있다.
- 원 서버에 대한 요청을 줄여준다. 이로 인해 서버의 부하를 줄일 수 있으며, 더 빨리 응답할 수 있게된다.
- 페이지를 먼 곳에서 불러올수록 긴 시간이 소요되나, 캐시를 통해 지연시간을 줄여준다.

### 1. 불필요한 데이터 전송

여러 클라이언트들이 하나의 서버에 동일한 문서를 요청을 하면, 동일한 데이터를 각각 전송해야하기 때문에 불필요한 데이터 전송으로 인해 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다.

캐시를 이용하면 첫 번째 서버 응답은 캐시에 보관되고, 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용되어 원 서버의 트래픽 낭비를 줄일 수 있다.

### 2. 대역폭 병목

일반적으로 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공하며 속도가 더 빠른 장점이 있다.

### 3. 갑작스런 요청 쇄도(Flash Crowds)

갑작스러운 사건(뉴스, 속보)등으로 트래픽 급증이 발생하는데, 캐싱을 잘 사용하여 이러한 현상에 대처를 할 수 있다.

### 4. 거리로 인한 지연

거리가 멀수록 서버로 부터 응답받는 지연시간이 늘어난다. 클라이언트 주변에 캐시를 두어 실질적인 거리를 줄일 수 있다.

### 5. 적중과 부적중

캐시는 유용하지만, 모든 문서의 사본을 저장하지는 않는다. (비용 문제와 최신 상태에 대한 문제)

캐시에 요청이 도착했을 때 대응하는 사본이 있는 경우 요청이 처리되며, 이를 캐시 적중이라고 한다.

반면, 대응되는 사본이 없는 경우는 원 서버로 전달되기만 한다. 이를 캐시 부적중이라고 한다.

## 1) 재검사

원 서버가 가지고 있는 콘텐츠는 변경될 수 있기 때문에 캐시된 사본이 최신인지 점검해야한다.

이를 `HTTP 재검사`라고 부르며, 콘텐츠의 일부를 가져와서 검사할 수 있는 특별한 요청을 정의했다.

캐시는 클라이언트가 사본을 요청했을 때 충분히 오래된 경우에만 재검사를 진행한다.

### 느린 적중

재검사는 원 서버에 작은 재검사 요청을 보내고, 콘텐츠가 변경되지 않았다면 아주 작은 사이즈의 `304 Not Modified` 라는 응답을 받는다. 캐시는 이를 신선하다고 표시한 뒤 클라이언트에 제공한다.

이를 `재검사 적중` 혹은 `느린 적중` 이라 한다.

이는 캐시 적중 보다는 느리나 캐시 부적중 보다는 빠르다. (서버로부터 객체 데이터를 받을 필요가 없기 떄문이다.)

![web4](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/381db0da-1202-4313-a923-1e13362da194)

HTTP는 캐시된 객체를 재확인하기 위해 몇 가지 도구를 제공하며, 가장 많이 사용되는 것은 `If-Modified-Since 헤더` 이다.

서버에게 보내는 `GET` 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.

`GET If-Modified-Since` 요청이 서버에 도착하는 경우 세가지 상황이 발생할 수 있다.

1. 서버 콘텐츠가 변경되지 않은 경우

2. 서버 콘텐츠가 변경된 경우

3. 객체가 삭제된 경우

### 재검사 적중

서버 객체가 변경되지 않았다면 `304 Not Modified` 라는 응답을 보낸다.

![web5](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/0b530831-21b0-4da0-8619-d65b90975a8a)

### 재검사 부적중

서버 객체가 캐시된 사본과 다르다면 서버는 콘텐츠 전체와 함께 `HTTP 200 OK` 응답을 보낸다.

### 객체 삭제

서버 객체가 삭제됬다면 서버는 `404 Not Found` 응답을 보내며, 캐시는 사본을 삭제한다.

## 2) 캐시 적중률

캐시가 요청을 처리하는 비율을 `캐시 적중률` 이라 하며, `0` 에서 `1` 의 값으로 되어있지만, `퍼센트` 로 표시되기도 한다.

`0%` 는 모든 요청이 캐시 부적중이며, `100%` 는 모든 요청이 적중된 경우다.

캐시 적중률이 `40%` 만 되어도 괜찮은 편이다.

얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지를 보여준다. 이를 개선하면 전체 지연시간이 줄어든다.

## 3) 바이트 적중률

큰 객체의 경우 덜 접근되지만, 그 크기로 인해 전체 트래픽에 더 영향을 끼친다.

바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현하며, 이 측정값은 트래픽이 절감된 정도를 포착해낸다.

바이트 단위 적중률 `100%` 는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.

바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지를 보여주며, 이를 개선하면 대역폭 절약을 최적화한다.

## 4) 적중과 부적중의 구별

HTTP는 클라이언트에게 응답이 캐시 적중되었는지, 아니면 원 서버 접근인지를 표현해주지 않는다.

두 경우 모두 응답코드는 `200 OK` 로 전달된다.

클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 `Date 헤더` 와 `Age 헤더` 를 통해 알 수 있다.

응답의 `Date 헤더` 값을 현재 시각과 비교하여 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.

응답이 오래되었는지 말해주는 `Age 헤더` 를 통해 알 수 있다.

# 6. 캐시 토폴로지

캐시는 한 명의 사용자에게만 할당될 수 있지만, 수천 명의 사용자들에게 공유될 수도 있다.

한명에게만 할당된 캐시는 `개인 전용 캐시(Private Cashe)` 라고 부르며, 한명의 사용자가 자주 찾는 페이지를 담는다.

공유된 캐시는 `공용 캐시(Public Cashe)` 라고 부르며, 사용자 집단에게 자주 쓰이는 페이지를 담는다.

## 1) 개인 전용 캐시

개인 전용 캐시는 많은 저장 공간을 필요로 하지 않으므로 작고 저렴하다.

웹 브라우저는 개인 전용 캐시를 내장하고 있으며, 자주 쓰이는 문서를 PC 의 디스크와 메모리에 캐시해놓는다.

사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

![web6](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/3f481e5b-4430-4982-b352-cdbc16c5b610)

## 2) 공용 프락시 캐시

공용 캐시는 `프락시 캐시` 라고 불리는 `프락시 서버` 다. 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있다. 처음 접근했을 때 객체를 단 한번만 가져와 사본을 공유하기 때문에 네트워크 트래픽을 줄인다.

## 3) 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 트래픽을 처리하도록 만드는 계층 방식이다.

클라이언트 단에는 작은 캐시 단위를 사용하고, 상단에는 문서를 공유하기 위한 더 크고 강력한 캐시를 사용하자는 형태이다.

단, 프락시 연쇄가 길어질수록 성능 저하가 심해진다.

# 7. 캐시 처리 단계

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다. (그리고 로컬에 저장한다.)
4. 신선도 검사 - 캐시는 캐시된 사본이 노후된 사본인지 확인하고, 노후되었다면 변경사항이 있는지 서버에 확인한다.
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅 - 선택적으로 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.
    
    ![web7](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/f76922fe-8da5-46f6-8df8-bab1c414a6a6)

## 1) 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다.

고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.

## 2) 파싱

캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.

이는 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어준다.

## 3) 검색

캐시는 URL을 알아내고 그에 맞는 로컬 사본이 있는지 검사한다. 로컬 복사본은 메모리에 저장됬을 수도 있고 디스크나 다른 PC에 있을 수도 있다. 만약 문서를 로컬에서 가져올 수 없다면 캐시는 상황이나 설정에 따라서 원 서버나 부모 프락시에서 가져오거나 실패를 반환한다.

캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다. 캐시된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 얼마나 자주 사용되었는지 등에 대한 몇몇 메타데이터를 포함한다.

## 4) 신선도 검사

HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다. 이 기간 동안 문서는 `신선` 한 것으로 간주되고 캐시는 서버와의 접촉 없이 문서를 제공할 수 있다. 하지만 일단 캐시된 사본이 너무 오래되었을 경우 그 객체는 `노후` 된 것으로 간주되어 변경점을 확인하기 위해 재검사를 진행한다.

신선도 검사 규칙은 매우 복잡하다.

## 5) 응답 생성

캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다. 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다.

캐시는 클라이언트에 맞게 이 헤더를 조정해야한다. 예를 들어 클라이언트가 HTTP/1.1 응답을 기대한다면 서버가 다른 응답을 반환한다면 헤더를 적절하게 번역해야한다.

또한, 캐시 신선도 정보를 삽입하며, 요청이 프락시 캐시를 거쳐갔음을 알려주기 위한 `Via 헤더` 를 종종 포함시킨다.

단, 캐시가 `Date 헤더` 를 조정해서는 안된다. `Date 헤더` 는 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것이다.

## 6) 전송

응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려준다. 프락시 캐시는 클라이언트와 커넥션을 유지할 필요가 있다. 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다.

## 7) 로깅

각 캐시 트랜잭션이 완료된 후 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 무엇이 일어났는지 알려주는 항목을 추가한다.

## 8) 캐시 처리 플로 차트

<img width="1000" alt="web8" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/f7b33a56-00fa-48bd-b6a6-9b7ab7006b77">


# 8. 사본을 신선하게 유지하기

문서들은 시간에 따라 변경될 수 있으며, 오래된 데이터를 제공하는 캐시는 불필요하다. 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야한다.

HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도 캐시된 사본이 서버와 일치하도록 유지하는 `문서 만료` 와 `서버 재검사` 라는 매커니즘을 가지고 있다.

## 1) 문서 만료

HTTP는 `Cache-Control` 과 `Expires` 라는 특별한 헤더를 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. (우유팩의 유통기한과 유사하다.)

이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태를 보일 수 있는지 보여준다.

![web9](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/8c6ef253-b04d-4614-b798-ab691576dc15)

캐시 문서가 만료되기 전이라면 캐시는 서버와의 접촉없이 사본을 제공할 수 있다. 그러나 캐시된 문서가 만료되면 캐시는 반드시 서버와 문서 사이의 변경점을 검사하고, 변경되었다면 새 유효기간이 달린 신선한 사본을 가져와야한다.

## 2) 유효기간과 나이

서버의 응답 헤더로 아래의 내용이 전달된다.

| 헤더 | 설명 |
| --- | --- |
| Cache-Control: max-age | max-age는 문서의 최대 나이를 정의한다.문서가 처음 생성된 이후부터 신선하지 않다고 변경될 때까지의 경과한 시간의 합법적 최대값(초 단위)이다.Cache-Control: max-age=484200 |
| Expires | 절대 유효기간을 명시한다.유효기간이 경과했다면 문서는 더 이상 신선하지 않다.Expires: Fri, 05 Jul 2002, 05:00:00 GMT |

## 3) 서버 재검사

캐시된 문서가 만료되었다는 것은 문서와 원 서버의 데이터가 다르다는 것을 의미하지는 않는다.

다만 검사할 시간이 되었음을 의미하며, 문서가 변경되었는지 여부를 물어보는 것을 `서버 재검사` 라고 부른다.

- 재검사 결과 컨텐츠가 변경되었다면 캐시는 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
- 재검사 결과 컨텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

캐시는 문서의 신선도를 매 요청마다 검증할 필요가 없고 문서가 만료되었을 때 한번만 서버와 재검사를 하면 된다.

서버 트래픽을 절약하고 사용자 응답 시간을 개선하는 방법이다.

### HTTP 프로토콜이 요구하는 캐시의 행동

캐시는 다음 중 하나를 반환하는 행동이 요구된다.

- `충분히 신선한` 캐시된 사본
- 원 서버와 재검사되었기 때문에 충분히 신선하다고 확신할 수 있는 캐시된 사본
- 에러메시지(재검사 해야하는 원 서버가 다운된 경우)
- 경고 메시지가 부착된 캐시된 사본

## 4) 조건부 메서드와의 재검사

HTTP는 캐시가 서버에게 `조건부 GET` 이라는 요청을 보낼수 있도록 해주며, 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 한다. `조건부 GET` 은 `GET` 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다. 웹 서버는 조건이 참인 경우에만 객체를 반환한다.

| 헤더 | 설명 |
| --- | --- |
| If-Modified-Since: | 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다.캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 Last-Modified 서버 응답 헤더와 사용된다. |
| If-None-Match: | 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 태그를 제공할 수 있다.If-None-Match 헤더는 캐시된 태그가 서버에 있는 문서 태그와 다를 때만 요청을 처리한다. |

## 5) If-Modified-Since: 날짜 재검사

가장 흔히 쓰이는 캐시 재검사 헤더는 `If-Modified-Since` 이다.

`IMS 요청` 이라고 불리며, 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

- 만약 날짜가 변경되었다면, 조건은 참이되고, GET 요청은 성공하며, 새 문서에 만료 날짜와 그 외의 정보들이 담긴 헤더와 함께 캬시에 반환된다.
- 만약 날짜 이후에 변경되지 않았다면, 조건은 거짓이고, 서버는 `304 Not Modified` 를 클라이언트에게 돌려주며, 별도의 본문은 전달하지 않는다. 응답은 헤더 및 갱신에 필요한 내용만 전달한다.예를 들어 `Content-Type` 헤더는 잘 변하지 않기에 보내지 않고, 새 만료 날짜는 보내준다.

`If-Modified-Since` 헤더는 응답 헤더인 `Last-Modified` 와 함께 동작한다.

원 서버는 제공하는 문서에 최근 변경 일시를 붙이고, 재검사하려고 할 때 사본이 마지막 수정된 날짜가 담긴 if-Modified-Since 헤더를 포함한다.

## 6) If-None-Match: 엔터티 태그 재검사

최근 변경 일시 재검사가 행해지기 어려운 경우, 태그를 비교해서 새 객체를 요청하는 방법으로 재검사를 진행하는 방법이다.

- 일정 간격으로 다시 쓰여지지만 동일한 데이터를 포함하는 문서
- 철자나 주석의 변경같이 사소한 변경으로, 전 세계 캐시가 변경하기엔 불필요한 문서

태그가 변경되지 않은 경우 새 객체를 요청하는 방식으로 재검사 여부를 확인한다.

![web10](https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/aa3bd7b3-2e46-4ec6-94c0-28fdc5f0fb1e)

만약 위의 경우 엔터티 태그가 변경되었다면 서버는 `200 OK` 응답으로 새 콘텐츠를 새 ETag 와 함께 반환한다.

## 7) 약한 검사기와 강한 검사기

`약한 검사기` 란 모든 캐시된 사본을 무효화시키지 않고 문서의 특정 부분만 고칠 수 있도록 허용하고 싶은 경우 사용하기 위한 방법이다. 단, 중요한 내용이 변경된 경우 변경된다. 이 방법은 `HTTP/1.1` 부터 지원한다.

추가적으로 조건부 특정 범위 가져오기 같은 몇몇 동작들은 서버에서 구분하지 못하기 때문에 `W/` 같은 접두사로 약한 검사기를 구분한다.

`강한 검사기` 란 콘텐츠가 바뀔때 마다 바뀐다.

## 8) 언제 태그를 사용하고 언제 Last-Modified 일시를 사용하는가?

- 서버가 엔터티 태그를 반환했다면 반드시 엔터티 태그 검사기를 사용해야한다.
- 서버가 `Last-Modified` 값만 반환했다면 클라이언트는 `If-Modfied-Since` 검사를 사용할 수 있다.
- 엔터티 태그와 최근 변경 일시가 모두 사용 가능하다면 HTTP/1.0 과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지의 재검사 정책을 사용해야한다.
- HTTP/1.1 원 서버는 실현 불가능하지만 않다면 엔터티 태그 검사기를 보내야하며, 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼수도 있다. 또한 `Last-Modified` 값을 같이 보내는 것도 선호된다.
- HTTP/1.1 캐시나 서버가 `If-Modified-Since` 와 엔터티 태그 조건부 헤더를 모두 받았다면 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 `304 Not Modified` 를 반환해서는 안된다.

## 게이트웨이

게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 한다.

### 프로토콜 게이트웨이

### 1) HTTP/* : 서버 측 웹 게이트웨이

<img width="1000" alt="web11" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/e37ea82a-c0b5-42f8-9aec-5930d7fbc401">

서버측 웹게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.

### 2) HTTP/HTTPS : 서버 측 보안 게이트웨이

<img width="1000" alt="web12" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/cd1422b5-4dea-4080-acfb-44e4ee116327">

클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다. 그러므로 개인 정보 보호와 보안을 제공할 수 있다.

### 3) HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이 (= SSL 오프로딩, SSL 터미네이션)

<img width="1000" alt="web13" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/171e7469-d794-4dd7-a030-66fb155928cd">

보안가속기로 불리며, HTTPS 트래픽을 받아 복호화 하고, 웹서버로 보낼 일반 HTTP 요청을 만든다. 원서버의 부하를 줄여주지만 암호화하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원서버 간에 있는 네트워크가 안전할 경우 사용해야한다.

### 리소스 게이트웨이

**`애플리케이션 서버도 게이트웨이의 일종`**. 애플리케이션 서버는 게이트웨이와 목적지 서버를 한 개의 서버로 결합하고 클라이언트와는 HTTP로 통신한다.

<img width="1000" alt="web14" src="https://github.com/shin5774/SSAFY_CS_Study/assets/70622601/927637d2-c708-4af4-9329-f046faaee6d2">

애플리케이션 게이트웨이에서 **`유명했던 최초의 API는 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)`** 였다.

> CGI
> 
> 
> 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행, 프로그램의 출력을 수집, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합
> 

## 터널

HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다. 웹터널을 사용하면 HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP위에 올릴 수 있다. ex) 웹 트래픽만 허용하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

## 릴레이

HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시다. 커낵션을 맺기 위한 HTTP 통신을 한다음, 바이트를 맹목적으로 전달한다. 단순 필터링이나 진단 혹은 컨텐츠 변환에 사용된다.