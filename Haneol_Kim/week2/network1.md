## 전송계층에 역할

물리 계층, 데이터 링크 계층, 네트워크 계층의 3계층이 있으면 목적지에 데이터를 보낼 수 있지만, 데이터가 손상되거나 유실되더라도 이것을 책임지지 않는다.

- 오류점검 해당 데이터가 어떤 애플리케이션에서 사용하는 데이터인지 판단한다.
- 데이터가 제대로 도착했는지 확인한다.

### 신뢰성/정확도와 효율성의 등과교환

- 신뢰성 중시 연결형 통신(TCP) : 상대편과 확인해 가면서 통신하는 방식 확인절차 O
- 효율성 중시 : 비연결형 통신(UDP) : 상대편을 확인하지 않고 보내느 방식 확인절차 X 영상에서 많이 사용

## TCP 특징

- 연결 지향 방식으로 패킷 교환 방식을 사용한다(가상 회선 방식이 아님)
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장한다
- UDP보다 속도가 느리다
- 전이중(Full-Duplex), 점대점(Point to Point) 방식.
- TCP 헤더가 붙은 데이터를 세그먼트라고 한다.

![헤더.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad6f97d0-173f-4a2a-be59-7d170c4d1666/c8b17853-5fac-4e7e-8b5b-5c18828a2ed1/%ED%97%A4%EB%8D%94.png)

### 포트번호

TCP헤더에는 출발지 포트번호와 목적지 포트번호가 존재한다. 이 포트번호를 통해 애플리케이션을 구분한다.

0 ~ 1023 포트는 주요 프로토콜이 사용한다. well known ports

1025 ~ : 랜덤포트라고 해서 클라이언트 측의 송신 포트로 사용된다.

웹브라우저에 접속할 때 웹브라우저에는 임의로 포트가 자동으로 할당이 돼서 서버측은 포트번호를 정해 둬야 하지만 클라이언트틑 정하지 않아도 된다. 

## 일련번호와 확인 응답번호

![확인 응답.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad6f97d0-173f-4a2a-be59-7d170c4d1666/b8fac6b5-4910-4846-8885-1592e17af415/%ED%99%95%EC%9D%B8_%EC%9D%91%EB%8B%B5.png)

## 흐름제어

### 재전송 제어

일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송 하도록 하는것 세그먼트 하나 단위로 함

### 윈도우 크기

위와 같은 방식은 한 번 보낼 때마다 한 번 응답을 반환하는 방식이어서 효율이 좋지 않다. 세그먼트를 연속으로 보내고 난 다음에 한번에 확인 응답을 반환하면 효율이 높아진다. 이를 저장하는것을 버퍼라 한다. 그리고 이 size를 윈도우 크기라고 한다. 3 way 핸드셰이크할때 size 판단한다.넘치면 오버플로가 발생할 수 있다.

### 슬라이딩 윈도우

TCP 헤더에서 표현할수 있는 윈도우 크기의 최대치는 2^16이다. 하지만 이는 옛날 기준으로 당연히 부족하다 그래서 3way hand shake때만 window의 scale값을 보내줘서 윈도우 사이즈가 크다는것을 알린다.

![슬라이딩1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad6f97d0-173f-4a2a-be59-7d170c4d1666/05d6ae62-6b9f-4d61-ad26-e6deab534fd4/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A91.png)

![수신2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad6f97d0-173f-4a2a-be59-7d170c4d1666/22459b64-d551-4fab-b199-309b2e4aa474/%EC%88%98%EC%8B%A02.png)

## 오류제어

## Stop And Wait

!https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F65c4bf54-4665-4036-b148-372780555a98%2Fimage.png

송신 측에서 패킷을 보내고, 보낸 패킷에 대한 응답이 오면 다음 패킷을 보내는 방식이기 때문에 만약 packet2를 보낸 후 timeout 이 발생한다면, 즉 보낸 packet 2 에 대한 응답이 없다면, 이를 다시 전송하면 되는 것이다!

하지만 만약 **Sliding Window를 사용한다면** 어떨까?

Sliding Window 는 윈도우에 있는 여러개의 데이터들을 연속적으로 보내는 방식이기에 이 경우 stop and wait 으로 오류제어를 한다면 sliding window 을 이용하는 의미가 전혀 없을 것이다!

이러한 이유로 **재전송 기반의 오류 제어, `ARQ (Automatic Repeat Request)`**를 사용하게 된다!

## ARQ (Automatic Repeat Request)

TCP는 기본적으로 재전송 기반의 오류 제어를 사용한다. 즉 통신중에 어떤 오류가 발생하면 송신 측에서 수신측으로 해당 데이터를 재전송하는 방식을 사용하여 오류 발생 상황을 해결한다는 의미이다.

하지만 실제로 수 많은 데이터를 주고 받아야 하는 네트워크 상황에서 이러한 재전송 방식은 그 자체로 비효율적이기 때문에 이러한 재전송을 최대한 적게하는 여러 방식으로 TCP는 오류를 제어한다!

ARQ를 이용한 오류 제어 방식엔 크게 두가지, **`Go Back N`과 `Selective Repeat`**이 있다!

## Go Back N

!https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F2e5a8940-7d93-48bc-beed-0a5918fccc91%2Fimage.png

Go Back N 에선, 송신측에서 여러개의 데이터를 연속적으로 보내다가 **오류가 발생한 데이터부터 다시 재전송하는 방식**을 사용한다!

위 그림에서, 송신측에서 0~2 패킷을 보낸 후 수신측은 이를 정상적으로 받은 후 송신측에게 ACK 3을 전송해 3부터 전송하면 된다고 알린다.

송신측이 3~5를 보냈는데, 그 중 4번이 유실되어 수신측이 받지 못했고, 수신측은 에러가 발생한 4번 데이터 이후의 데이터는 모두 폐기한다. 즉, 수신측에서 5번 데이터를 폐기한 후 4번이 유실되었음을 송신측에 알린다! `NAK 4`

이때 송신측은, 유실된 데이터인 4번부터 다시 데이터를 전송하게 되는데, 4~5를 재전송 하여 오류를 해결한다!

하지만 이러한 방식 역시 **이미 수신한 데이터를 폐기하고 다시 재전송해야 한다는 단점**이 존재한다. 이러한 단점을 보완하는 것이 `Selective Repeat`방식이다.

## Selective Repeat

이름처럼 오류가 발생한 데이터만을 골라서, 재전송하는 방식이다!

!https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F2def564a-111b-477e-a3ae-d182fdc0f477%2Fimage.png

위와 동일하게 4번 패킷에서 오류가 발생했고 이를 수신측이 송신측에 알리지만, 수신측은 이미 받은 5번 데이터를 폐기 하지 않는다!

송신측은 **오류가 발생한 4번 패킷만을 재전송하고 수식측이 이를 정상적으로 받으면 송신측은 다시 6번 부터 전송을 시작**하면 되는 것이다.

하지만 이 때 수신측의 수신 버퍼는 어떤 형태일까?

0,1,2,3 이 차곡차곡 쌓이다가, 4번을 수신하지 못하고 5번을 수신, 이후 4,6을 수신,, 말하자면 수신측의 버퍼는 `0-1-2-3-5-4-6` 과 같은 순서일 것이다!

즉, **Selective Repeat 방식에서는 수신측의 버퍼에 순서가 보장되지 않는다는 단점이 존재**한다!

때문에 수신 버퍼에 대한 `재정렬`이 필요하고, 이는 필연적으로 또 **다른 버퍼 공간을 필요**로 한다는 단점이 있다!

## 혼잡제어

- 네트워크 혼잡을 피하기 위해 ***송신 측에서 보내는 데이터의 전송 속도를 제어***하는 것
- 송신 측 데이터 전달과 네트워크 데이터 처리 속도 차이를 해결하기 위한 기법
- 한 라우터에 데이터가 몰려서 모든 데이터를 처리할 수 없는 상황에 이르렀을 때, 호스트들은 계속해서 재전송을 하고 결과적으로 혼잡만 가중시켜 오버플로우나 데이터 손실이 발생한다.

### 혼잡제어 알고리즘

TCP 혼잡제어 알고리즘(TCP congestion control algorithm)은 다음의 중요한 구성요소들을 갖는다.

1. 슬로 스타트(slow start)
2. 혼잡 회피(congestion avoidance)
3. 빠른 회복(fast recovery)
4. 빠른 재전송(fast retransmit)

이 중 `슬로스타트`와 `혼잡회피`는 TCP의 필수 요소이다. 다만 수신된 ACK들에 대응해 cwnd(congestion window) 크기를 얼마나 증가시키냐는 것이 서로 다르다. `빠른회복`은 TCP 송신자들에게는 필수 사항은 아니다.

> cwnd?
> 
> 
> 혼잡 윈도우는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한한다. 특히 송신하는 쪽에서 확인응답이 안된 데이터의 양은 cwnd 와 rwnd의 최솟값을 초과하지 않는다.
> 

### 1. 슬로우 스타트

!https://velog.velcdn.com/images%2Fchullll%2Fpost%2Fa721c0b1-9ec8-4bdf-bd28-2ec540def9e6%2Fimage.png

- 전송 성공 시 ACK 패킷마다 cwnd를 1씩 증가시킨다. 즉, 한 주기가 끝나고 나면 cwnd는 2배배가 된다.
- 혼잡 현상이 발생하면 cwnd 를 1로 떨어뜨린다.

!https://velog.velcdn.com/images%2Fchullll%2Fpost%2Fb1c1e748-29cf-4970-bcac-0422df0fd0c5%2Fimage.png

- 한번 혼잡 현상이 발생하고 나면 혼잡 현상이 발생했던 cwnd 의 절반까지는 이전처럼 증가시키다가 그 이후부터는 완만하게 1씩 증가시킨다.
- 즉, 임계 값(ssthresh, slow start threshold)을 절반으로 줄인다.
- 매 전송마다 2배씩 증가하기 때문에 데이터의 크기가 지수함수적으로 증가한다.
- 파악한 임계 값에 도달하기 전까지 2배씩 증가, 임계값 도달 시 혼잡 회피 단계로 넘어간다.

### 2. 혼잡 회피

- 윈도우 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 크기가 올라감
- 이를 회피하기 위해 cwnd 크기를 전송 시마다 1 씩 증가시킨다.
- 수신 측으로부터 일정 시간동안 ACK 를 받지 못하면, 타임 아웃이 발생해 cwnd 크기를 1로 줄인다.
- 동시에 임계 값을 패킷 손실이 발생했을 때의 cwnd 크기의 1/2로 줄인다.

### 3. 빠른 회복

- 혼잡한 상태가 되면 cwnd 를 1이 아니라 절반으로 줄이고 선형 증가 시키는 방법
- 빠른 회복 정책이 적용되면 이후엔 순수한 AIMD 방식으로 동작

### 4. 빠른 재전송

!https://velog.velcdn.com/images%2Fchullll%2Fpost%2F0525c9e9-9686-4588-8c83-136e8624549e%2Fimage.png

- 패킷을 받는 수신자 입장에서 세그먼트로 분할된 내용이 순서대로 도착하지 않는 경우가 있다.
- 수신 측에서 패킷을 받을 때 먼저 올 패킷보다 다음 패킷이 먼저 도착해도 ACK 를 보냄
- 단, 이 때 순서대로 잘 도착한 패킷의 마지막 순번을 ACK 에 실어서 보냄
- 따라서 중간에 패킷이 손실되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 되는 것이다. 이것을 감지하면 문제가 되는 순번의 패킷을 재전송할 수 있다.
- 빠른 재전송은 중복된 순번의 패킷을 3개 받으면 재전송한다.
- 재전송하는 경우 혼잡 상태로 간주하고 혼잡 회피를 한다.

### AIMD(Addictive Increase Multiplicative Decrease)

!https://velog.velcdn.com/images%2Fchullll%2Fpost%2F7f6f3777-a305-411b-be15-c3caf9a782be%2Fimage.png

- 합 증가/ 곱 감소 알고리즘 이라고도 한다.
- 처음 패킷 하나를 보내 패킷이 문제없이 도착하면 CWND(Congestion Window, 혼잡 윈도우)를 1씩 증가시키면서 전송하는 방법
- 패킷 전송이 실패하거나 타임아웃이 발생하면 CWND를 1/2로 감소시킨다.
- 호스트가 하나의 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 불리하지만 시간이 지날수록 평형 상태로 수렴한다
- 단점은, 초기 넓은 대역폭을 활용하지 못하고 미리 혼잡 상태를 감지하지 못하고 혼잡해지고 나서야 대역폭을 줄이는 방식이라는 점이다.

![udp.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad6f97d0-173f-4a2a-be59-7d170c4d1666/09f478db-0591-4879-9dd4-12c1938fa13b/udp.png)

### UDP 특징

- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다
- UDP 헤더가 붙은 데이터를 UDP 데이터 그램이라고 한다.
- 브로드캐스트 가능하다.