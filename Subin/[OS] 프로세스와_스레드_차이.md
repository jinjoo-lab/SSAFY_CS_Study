# 프로세스와 스레드의 차이

### [프로세스와 스레드]

- **프로세스**
    
    운영체제로부터 자원을 할당받은 작업의 단위
    
    ⇒ 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태
    
    작업중인 프로그램
    
- **스레드**
    
    프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위
    
    ![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98_%EC%B0%A8%EC%9D%B4/Untitled.png)
    
    : 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 
    
      하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
    
      프로세스 생성 → main 스레드 생성
    

### [스레드의 등장 배경]

프로세스의 한계를 해결하기 위해 등장

과거: 프로그램을 실행할 때 하나의 프로세스만 사용

→ 기술의 발전에 따른 프로그램의 복잡도 증가 ⇒ 한계 발생!

동일한 프로그램을 여러 개의 프로세스로 생성하면, 메모리 할당과 중복 자원 할당(CPU) 문제 발생

⇒ 스레드 탄생

### [프로세스의 메모리 구조]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98_%EC%B0%A8%EC%9D%B4/Untitled%201.png)

- **스택과 힙**
    
    동적 할당 (런타임 단계에서 메모리 할당)
    
    스택은 위 주소부터 할당 / 힙은 아래 주소부터 할당
    
    > **스택 영역**
    > 
    > 
    > 지역변수, 매개변수, 실행되는 함수에 의해 늘거나 줄어드는 메모리 영역
    > 
    > 호출한 함수가 종료되면 되돌아올 임시 자료를 저장하는 공간
    > 
    > 함수 호출 시 할당, 함수 호출 종료 시 소멸
    > 
    
    > **힙 영역**
    > 
    > 
    > 생성자, 인스턴스와 같은 동적으로 할당되는 데이터를 저장하는 공간
    > 
    > malloc(), free() 함수로 관리
    > 
    
    <aside>
    🍒 스택 영역과 힙 영역이 만나면?
    Overflow 발생!
    Heap Overflow : heap이 stack 영역을 침범한 경우
    Stack Overflow : stack이 heap 영역을 침범한 경우
    
    </aside>
    
- **데이터 영역과 코드 영역**
    
    정적 할당 (컴파일 단계에서 메모리 할당)
    
    > **데이터 영역**
    > 
    > 
    > 전역 변수나 각종 데이터를 저장하는 공간
    > 
    > 전역 변수 또는 static, const로 선언되어 있는 변수 中
    > 
    > BSS segment → 0으로 초기화 / 초기화 X
    > 
    > Data segment → 0이 아닌 값으로 초기화
    > 
    > <aside>
    > 🍒 BSS와 DATA 영역을 구분하는 이유?
    > 초기화 된 데이터는 초기 값을 저장해야 하므로 Data 영역에 저장되어 rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 rom에 저장되면 큰 size의 rom이 필요하므로 구분한다. ( `초기화 되지 않은 데이터는 ram에 저장` )
    > 
    > </aside>
    > 
    
    > **코드 영역**
    > 
    > 
    > 프로그램 코드가 저장되는 공간
    > 
    > 기계어로 제어되는 메모리 영역
    > 
    

### [스레드의 메모리 구조]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98_%EC%B0%A8%EC%9D%B4/Untitled%202.png)

여러 개의 스레드는 각각 레지스터와 스택을 할당받고,

코드, 데이터, 힙 영역은 프로세스의 영역을 공유받는다.

⇒ 스레드는 프로세스의 모든 데이터에 접근 가능

⇒ 데이터, 힙 영역을 공유하고 있어 IPC 없이도 스레드 간 통신 가능

<aside>
🍒 스레드가 고유한 스택을 할당받는 이유?
스레드는 함수의 호출로 실행되고, 스택 영역은 함수 호출 시 할당된다.

</aside>

### [프로세스와 컴파일 과정]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98_%EC%B0%A8%EC%9D%B4/Untitled%203.png)

- 프로세스
    
    프로그램이 메모리에 올라가 인스턴스화된 것
    ex) 프로그램은 크롬과 같은 실행 파일이며, 이를 두 번 클릭하면 구글 크롬 프로세스로 변환됨
    
- 프로그램을 만드는 과정
    
    언어마다 상이
    
    C언어 기반의 프로그램 기준: 컴파일러가 컴파일 과정을 통해 기계어로 변환
    
- 컴파일
    
    전처리, 컴파일러, 어셈블러, 링커의 과정을 거치며 이루어짐
    [전처리] 소스코드의 주석을 제거하고 헤더 파일을 병합하여 매크로를 치환하는 과정
    [컴파일러] 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환하는 과정
    [어셈블러] 목적 코드로 변환. 예를 들어 리눅스에서는 이 과정을 통해 소스코드.c에서 소스코드.o라는 확장자를 가지는 파일이 만들어짐
    [링커] 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만드는 과정
    

### [프로세스의 상태]

프로세스가 실행되는 동안 변경되는 고유 상태

- **생성 상태**
    
    프로세스가 생성된 상태. fork() 또는 exec() 함수를 통해 생성
    
    이 때 PCB 할당
    
    <aside>
    🍒 fork()와 exec()의 차이는?
    **fork** 
    부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스 생성
    
    주소 공간만 복사할 뿐, 부모 프로세스의 비동기 작업 등을 상속하지는 않음!
    **exec**
    새롭게 프로세스 생성
    
    </aside>
    
- **대기 상태**
    
    메모리 공간이 충분하면 메모리를 할당 받고 아니면 그냥 대기
    
    CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태
    
- **대기 중단 상태**
    
    메모리 부족으로 일시 중단된 상태
    
- **실행 상태**
    
    CPU 소유권과 메모리를 할당 받고 명령을 수행 중인 상태 (=CPU burst)
    
- **중단 상태**
    
    어떤 이벤트가 발생한 이후 자원을 기다리며 프로세스가 차단된 상태
    
    I/O 디바이스에 의한 인터럽트로 많이 발생
    
- **일시 중단 상태**
    
    대기 중단 상태와 유사
    
    중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태
    
- **종료 상태**
    
    메모리와 CPU 소유권을 모두 놓고 가는 상태
    
    자발적 종료 / 비자발적 종료 (부모 프로세스가 자식 프로세스를 강제 종료)
    
    <aside>
    🍒 비자발적 종료가 발생하는 이유?
    
    1. 자식 프로세스가 할당된 자원의 한계치를 넘을 때
    2. 사용자가 process.kill 등 명령어로 프로세스를 종료할 때
    </aside>
    

### [프로세스 상태 변이]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98_%EC%B0%A8%EC%9D%B4/Untitled%204.png)

### [스레드의 상태]

- **생성 상태**
스레드가 생성되고 아직 호출되지 않은 상태
- **실행 대기 상태**
스레드가 실행되기 위해 기다리는 상태
CPU를 할당받을 수 있는 상태
- **일시정지 상태**
    
    Waiting
    
    다른 스레드가 특정 작업을 수행하기까지 대기하는 상태
    
    Timed_Waiting
    
    지정된 대기 시간 동안 대기하는 상태
    
    Blocked
    
    IO관련 상태 또는 synchronized를 통해 스레드 진행이 정지된 상태
    
    스레드를 정지 원인 해소 시 ready 상태로 복귀
    
- **종료 상태**
스레드가 실행을 완료하고 종료된 상태
더 이상 실행될 수 없으며, 메모리에서 제거됨

### [PCB]

*Process Control Block, 프로세스 제어 블록*

운영체제가 프로세스를 제어하기 위해 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터‘

각 프로세스가 생성될 때마다 고유의 PCB가 생성(커널 영역)되고, 프로세스가 완료되면 PCB는 제거

> 프로그램이 실행되면 프로세스가 생성되고, 프로세스 주소 값들에 메모리 할당
이 프로세스의 메타데이터들이 PCB에 저장되어 관리
프로세스의 중요한 정보를 포함하고 있기 때문에 커널 스택의 가장 앞에서 관리됨
> 

**PCB 구조**
: 프로세스 스케줄링 상태, 프로세스 ID, 프로세스 권한 등의 정보로 이루어짐

**컨텍스트 스위칭**

: PCB를 교환하는 과정

### [TCB]

하나의 스레드를 관리하는 데 필요한 정보를 담고 있는 구조체

PCB가 레퍼런스 형식으로 TCB 목록을 가짐

### ~~[스레드의 자원 공유]~~

: 멀티스레드 파트에서 ..!
