# TCP 3, 4 way handshake

https://www.notion.so/TCP-3-4-way-handshake-ea9d98e8237d4f79aa8de314622425ad

### [3-way handshake]

TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정

(= 상대방 컴퓨터와 사전에 세션을 수립하는 과정)

- **정확한 전송 보장**
    
    양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장한다.
    
    ⇒ 데이터 전달이 시작하기 전에 다른 쪽이 준비되었다는 것을 알 수 있다.
    

### [기본 메커니즘]

PAR을 통해 신뢰성 있는 통신 제공

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20TCP%EC%99%80_3%2C4_way_handshake/Untitled.png)

수신자가 데이터 세그먼트가 손상된 것을 확인하면, 해당 세그먼트를 제거한다.

발신자는 positive ack가 오지 않은 데이터 세그먼트를 재전송해야 한다.

⇒ 이 과정에서 클라이언트와 서버 사이에 3개의 세그먼트가 교환된다.
     3-way handshake의 기본 메커니즘.

<aside>
🍒 **PAR**

Positive Acknowledgement with Re-transmission

PAR을 사용하는 기기는 ack를 받을 때까지 데이터 세그먼트를 재전송한다.

</aside>

<aside>
🍒 수신자가 데이터 세그먼트의 손상을 확인하는 방법

⇒ checksum 활용

</aside>

### [동작 과정]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20TCP%EC%99%80_3%2C4_way_handshake/Untitled%20(1).png)

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20TCP%EC%99%80_3%2C4_way_handshake/Untitled%20(2).png)

1. 클라이언트는 접속을 요청하는 SYN 세그먼트를 보낸다.
    
    이 때 클라이언트는 응답을 기다리기 위해 SYN_SENT 상태로 변한 후 대기한다.
    
    SYN 세그먼트에는 연결 확인을 위해 전송하는 무작위의 숫자 값이 들어있다.
    
2. LISTEN 상태였던 서버는 SYN 요청을 받으면, 클라이언트에게 요청을 수락하는 ACK 세그먼트와 SYN 세그먼트를 보낸다.
    
    (서버도 클라이언트에 접속해야 양방향 통신이 되기 때문에)
    
    그리고 서버는 SYN_RCVD(SYN_RECEIVED)상태로 변하여 클라이언트가 ACK 세그먼트를 보낼 때 까지 기다리게 된다.
    
    이 때 ACK 세그먼트에는 Client로부터 받은 SYN에 1을 더한 값이 들어있다.
    
3. SYN과 ACK를 받은 클라이언트는 ESTABLISHED 상태로 변경하고 다시 서버에 ACK 세그먼트를 보낸다.
    
    이후 ACK 세그먼트를 받은 서버 역시 ESTABLISHED 상태로 변경된다.
    

<aside>
🍒 초기 ISN(Sequence Number)을 난수로 설정하는 이유?

⇒ 보안과 유일성 확보

서버는 세그먼트의 SYN을 보고 세그먼트를 구분해야 하는데, 난수가 아닌 순차적인 Number가 전송된다면 이전의 Connection으로부터 오는 세그먼트로 오인될 수 있다. 

⇒ ISN을 난수로 설정함으로써, 서로 다른 연결이 사용한 Sequence Number가 중첩되는 문제를 예방하고 보안적 측면에서 안전성을 높인다.

</aside>

### [4-way handshake]

네트워크 연결을 해제하는 과정

- **FIN 세그먼트 사용**
    
    더 이상 보낸 데이터가 없음을 의미
    
    ⇒ 세션을 종료시키는 데 사용
    

### [연결 해제 방식]

- **Grace connection release**
    
    > “정상적인 연결 해제”
    > 
    > 
    > 양 쪽이 모두 연결을 닫기 전까지 유지
    > 
    
    **half-close 기법 사용**
    
    <aside>
    🍒 **half-close 기법**
    
    연결 종료 시 완전히 종료하지 않고 반만 종료하는 방법
    
    실질적으로 종료 요청자가 첫 FIN 세그먼트에 ACK를 포함한다.
    
    > **ACK 의미?
    "일단 연결은 종료할건데, 귀는 열어둘게. 이 승인 번호(ACK)까지 처리했으니까 더 보낼 거 있으면 보내”*
    > 
    
    ⇒ 수신은 가능하므로 하고 있던 작업을 마무리할 수 있다.
    
    이후 수신자는 남은 데이터를 모두 전송하고 다시 요청자에게 FIN 패킷을 전송함으로써 모든 데이터가 처리되었음을 알린다.
    
    ⇒ 요청자는 나머지 반을 닫으면서 안전하게 연결을 종료할 수 있다.
         데이터 손실이나 불완전한 연결 종료로부터 발생하는 문제 방지. 안정적인 통신 제공
    
    </aside>
    
- **Abruct connection release**
    
    > “갑작스러운 연결 해제”
    > 
    > 
    > 갑자기 한 TCP 엔티티가 연결을 강제로 닫는 경우
    > 
    > 한 사용자가 두 데이터 전송 방향을 모두 닫는 경우
    > 
    
    **RST 세그먼트가 전송되는 경우 수행**
    
    <aside>
    🍒 **RST 세그먼트**
    
    = TCP Reset 세그먼트
    
    **RST 세그먼트가 전송되는 경우**
    
    1. 존재하지 않는 TCP 연결에 대해 비SYN 세그먼트가 수신된 경우
        
        만약 서버가 SYN 세그먼트를 받지 않은 상태에서 다른 종류의 세그먼트를 받게 되면, 이는 존재하지 않는 연결에 대한 연결 시도라고 간주된다.
        
        ⇒ 수신자는 RST 세그먼트를 전송하여 해당 시도를 거부하고 상태를 초기화한다.
        
    2. 통신 중 잘못된 헤더가 있는 세그먼트가 수신된 경우
        
        ⇒ 해당 연결을 끊고, 재설정하려는 시도로 RST 세그먼트를 전송한다.
        
    3. 기존 TCP 연결을 종료해야 하는 경우
        
        1) 연결을 지원하는 자원이 부족한 상황
        
        2) 원격 호스트에 연결할 수 없고, 응답이 중지된 상황
        
    </aside>
    

### [동작 과정]

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20TCP%EC%99%80_3%2C4_way_handshake/Untitled%20(3).png)

1. 서버와 클라이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 CLOSE() 함수를 호출한다.
    
    이후 서버에 FIN 세그먼트를 보내게 되고 클라이언트는 FIN_WAIT1 상태로 대기한다. 이때, FIN 세그먼트에는 실질적으로 ACK 세그먼트도 포함되어 있다.
    
2. 서버는 클라이언트가 CLOSE() 한다는 것을 알게 되고 CLOSE_WAIT 상태로 바꾼 후 응답 세그먼트인 ACK 세그먼트를 전송한다.
    
    동시에 해당 포트에 연결되어 있는 애플리케이션에게 close를 요청한다.
    
    만일 서버에서 클라이언트로 보낼 남은 데이터가 있을 경우 이때 나머지를 모두 전송시킨다.
    
3. ACK를 받은 클라이언트는 상태를 FIN_WAIT2로 변경한다.
4. CLOSE 요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 FIN을 클라이언트로 보내 LAST_ACK 상태로 바꾼다.
5. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 ACK 세그먼트를 보낸 후 TIME_WAIT 상태로 전환된다.
    
    이 때 TIME_WAIT 상태는 의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지하는 의미이다.
    
    TIME-WAIT에서 일정 시간이 지나면 CLOSE 된다. ACK를 받은 서버도 포트를 CLOSED로 닫는다.
    
    새 연결과 겹치지 않도록 일정 시간 기다린 후 CLOSED 상태로 변경된다.
    

<aside>
🍒 **연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 차이나는 이유?**

데이터 전송의 특성과 연관이 있다.

연결 설정에서는 클라이언트가 서버에게 연결을 요청하고, 서버가 수락하는 3단계의 과정이 필요하다. 

반면 연결 종료에서는 데이터 전송이 완료된 후에 종료하는데, 이때 서버가 아직 보낼 데이터가 남아있을 수 있다.

⇒ 클라이언트가 데이터 전송을 마친 경우에도 서버는 아직 보낼 데이터가 남아있을 수 있어 일단 FIN에 대한 ACK만을 보내고, 데이터를 모두 전송한 후에 서버가 FIN 메시지를 보내어 연결을 종료한다!

</aside>

### [관련 공격]

> **SYN Flooding**
> 
> 
> 공격자가 대상 서버에 대량의 SYN 요청 세그먼트를 보내 서버의 자원을 고갈시키는 공격
> 

![Untitled](https://github.com/ksb3458/SSAFY_CS_Study/blob/main/Subin/%5Bimg%5D/%5Bimg%5D%20TCP%EC%99%80_3%2C4_way_handshake/Untitled%20(4).png)

1. 공격자가 서버로 대량의 SYN 요청 세그먼트를 전송한다.
    - 서버는 SYN 세그먼트를 받으면 해당 연결에 대한 정보를 백 로그 큐에 저장하여 관리한다.
    - SYN 세그먼트가 대량으로 도착하면 백 로그 큐가 급격히 증가하면서 서버 자원이 소진된다.
    - 이로 인해 서버는 새로운 연결을 처리할 수 없고, 서비스의 가용성이 급격히 감소한다.
2. SYN을 수신한 서버는 SYN+ACK 세그먼트를 전송하고 ACK를 받을 때까지 대기한다.
    - 공격자는 ACK를 전송하지 않고 계속해서 서버를 대기 상태로 유지시킨다.
    - 이로 인해 서버의 연결 테이블은 half-open 상태의 연결로 가득 차게 되고, 
    새로운 연결을 수락할 수 없다.
    - 서버는 결국 연결 테이블이 고갈되어 서비스 거부 상태에 도달하게 된다.
