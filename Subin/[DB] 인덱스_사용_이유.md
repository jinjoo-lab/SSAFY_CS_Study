# DB에서 인덱스 사용 이유 & 장단점

### [인덱스]

데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

데이터와 데이터의 위치를 포함

인덱스는 보통 B-트리 자료 구조로 이루어짐

### [B-트리]

루프 노드, 리프 노드, 브랜치 노드 (루프 노드 - 리프 노드 사이)

균형 트리

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/93e932aa-238e-4c21-92c0-b3a86388ec72/4c27357f-74a3-4536-86dc-429fc4245413/Untitled.png)

- 탐색 과정 - 57 찾기
    
    트리 탐색은 루트 노드부터 시작되어 브랜치 노드를 거쳐 리프 노드까지 내려온다.
    57보다 같거나 클 때까지의 조건을 기반으로 처음 루트 노드에서는 39, 83 이후 아래 노드로 내려와 46, 53, 57 등 정렬된 값을 기반으로 탐색한다.
    이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 57이 가리키는 데이터 포인터를 통해 결과값을 반환하게 된다.
    즉, 찾는 값인 57보다 같거나 클 때까지를 기반으로 탐색하다가 리프 노드에 도착해서 57이 가리키는 데이터 포인트를 통해 값을 반환하는 것이다.
    

<aside>
🍒 B-트리와 B+트리의 차이는?
B- 트리 : 브랜치 노드에 key와 data 저장 가능
B+트리 : 브랜치 노드에 key만 저장. 
               리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결
               ⇒ B-트리의 확장개념. (InnoDB는 B+트리로 이루어짐)

</aside>

### [인덱스가 효율적인 이유]

- 균형 잡힌 트리 구조
    
    효율적인 단계를 거쳐 모든 요소에 접근 가능
    
- 트리 깊이의 대수확장성
    
    트리 깊이가 리프 노드 수에 비해 느리게 성장
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/93e932aa-238e-4c21-92c0-b3a86388ec72/d60d286b-dd35-44ce-9d5c-8665d72ed9c9/Untitled.png)
    
    일반적으로 인덱스가 한 깊이씩 증가할 때마다 인덱스 항목의 수는 최대 4배씩 증가
    
    ⇒ 트리 깊이가 10인 경우, 100만 개의 레코드 검색 가능
    

### [인덱스 장점]

- **테이블 검색 속도 향상**
    - WHERE절 - Full Table Scan
    인덱스 - 데이터 정렬 ⇒ 조건 검색 시 빠르게 검색 가능
    - ORDER BY절 - SORT 필요 (메모리에서 정렬 → 메모리보다 큰 겨우 디스크 I/O를 통해 정렬)
        
        인덱스 - SORT 과정 생략 가능
        
    - MAX, MIN - Full Table Scan
        
        인덱스 - Max : 레코드 마지막 값, Min : 레코드 시작 값
        

### [인덱스 단점]

- 인덱스 관리 위한 추가적인 작업 필요
    
    인덱스 정렬된 상태 유지 ⇒ 인덱스가 적용된 Column에 삽입, 삭제, 수정 작업 수행 시 추가 작업!
    
    INSERT : 새로운 데이터에 대한 인덱스 추가 연산 필요
    
    DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 필요
    
    UPDATE : 기존의 인덱스를 사용하지 않게 처리, 갱신된 데이터에 대한 인덱스 추가 연산 필요
    
    <aside>
    🍒 DELETE/UPDATE 작업 시, 기존 인덱스를 제거하지 않고, ‘*사용하지 않음*’으로 처리!
    ⇒ 실제 데이터에 비해 인덱스가 과도하게 커질 수 있다!
    
    </aside>
    
- 추가 저장 공간 필요
    
    데이터베이스의 약 10% 정도
    
- 인덱스 잘못 관리 시 성능 저하
    
    수정 작업이 빈번한 속성에 인덱스 적용 시 → 인덱스 크기 증가 ⇒ 성능 저하
    

### [인덱스를 사용하면 효율적인 경우]

- 규모가 큰 테이블
- INSERT, UPDATE, DELETE 작업이 자주 발생하지 않는 컬럼
- WHERE, ORDER BY, JOIN에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
