### DB

> 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.
>

# Index -1 (인덱스 자료구조 - Scan)

### Index

- 사전적 정의 : **색인**
    - 데이터를 효율적으로 조회하기 위해 사용하는 자료구조 (검색 성능을 향상)
    - 인덱스의 조건
        - 구별
            - 데이터 베이스에서 조회하기 위해서는 **데이터를 식별**할 수 있는 존재가 필요하다**(칼럼)**
        - 정렬
            - **정렬**을 통해 데이터를 효과적으로 탐색할 수 있고 데이터의 유무또한 판단하기 쉽다.

> 인덱스란 데이터의 조회(SELECT)의 성능을 높이기 위한 자료구조이며 해당 레코드를 식별할 수 있는 기준이 되며 **정렬된 상태를 유지**한다.
>
- **장점**
    - 데이터의 조회(SELECT)의 속도가 빠르다 (성능이 좋다)
        - 서비스의 종류에 따라 검색의 비율이 절대적으로 많은 경우가 있다.
- **단점**
    - 인덱스 관리를 위한 **추가적인 저장공간**을 필요로 한다.
        - 인덱스 또한 데이터베이스의 객체이다. (저장이 필요하다)
    - 인덱스를 사용할 경우 **삽입, 수정, 삭제**의 성능이 떨어진다. (추가적인 연산 비용을 필요로 한다.)
- **삽입 , 수정 , 삭제**

  핵심은 **정렬**이다. 효율적인 탐색을 위해 데이터나 데이터 주소를 정렬해 놓을 경우 삽입 , 수정 , 삭제 시 데이터의 위치를 탐색해야 하기 때문에 속도가 떨어진다.

- **고찰**

  인덱스를 거치는 것은 거치지 않는 것보다 당연히 추가적 비용이 발생하는 작업이다.

  > 일반적인 DBMS 옵티마이저 → 인덱스를 통한 1건의 검색 = 인덱스를 통하지 않는 5건의 검색
  >
    - 인덱스를 통한 검색의 범위가 전체 테이블 레코드의 20 ~ 25 %라면 풀 테이블 스캔이 이득이라는 것
    - Why : 순차 I/O , Random I/O 의 차이

### 중복

> 인덱스가 중복이 가능한가 불가능한가에 따라 구분을 할 수 있다.
>
- PK
    - 데이터 베이스의 PK는 기본적으로 **중복이 불가능**하다. 그렇기 때문에 고유하게 식별할 수 있는 인덱스의 역할도 수행한다.
- 세컨더리 인덱스
    - PK를 제외한 모든 인덱스

### 인덱스 선택 기준

- 인덱스의 선택 기준
    - 카디널리티 (Cardinality)
        - 테이블에서 해당 데이터의 고유성을 나타내는 개념
        - 전체 데이터 개수(Row)에 대한 **특정 칼럼의 중복 수치**를 나타내는 지표
            - 중복도가 높으면 카디널리티는 낮다
        - 카디널리티는 테이블을 기준으로 **상대적인 평가**가 이루어진다.

    ```sql
    CREATE TABLE `used_car` (
      `license_number` VARCHAR(256), # 차량 등록 번호
      `price` int, # 가격
      `save_price` int, # 절감 가격
      `insurance_id` BINARY(16), # 보험 번호
      `created_at` timestamp,
      `updated_at` timestamp
    );
    ```

  > 중고차 테이블을 예시로 설명을 하자면 차량 등록 번호는 겹칠 수 없다. 이런 경우 **카디널리티가 높다**. (중복도가 낮다) 즉 인덱스로 사용하기 적합하다고 판단할 수 있다.
  >
    - 선택도 (Selectivity)
        - 선택도는 카디널리티를 기반으로 한 개념이다. **(카디널리티) / (전체 데이터의 개수)** 즉 비율이라고 생각하면 된다.
        - **선택도가 높을수록** 인덱스에 적합하다.

## 인덱스 자료구조

### HashTable

- Key - Value 형태로 데이터를 저장
    - 칼럼의 값으로 해시값 계산 → **Key(Index)**
- 굉장히 빠른 성능의 조회 속도를 가진다 → O(1)
- Equal 연산을 수행하는 경우에 유효하다. 그렇지 않은 경우 Full Scan
    - **범위 검색이 불가능**하다.
        - Index 값이 해싱 처리가 되었기 때문에 구간 탐색이 불가능하다.

### B-Tree

- **이진 탐색 트리**
    - 이진 탐색 트리란 자식 노드의 개수가 최대 2개이다.
    - 부모 노드를 기준으로
        - 왼쪽 서브 트리는 **키 값이 작은** 노드들
        - 오른쪽 서브 트리는 **키 값이 큰** 노드들
- **이진 탐색 트리의 단점**
    - 편향 트리일 경우 최악인 경우이며 시간 복잡도가 O(N)이다.
    - 쉽게 말하자면 특정한 경우에 트리의 구조가 불균형하다는 것이다.
- **B - Tree ( Balanced )**
    - **모든 리프 노드들이 같은 레벨을 가지는 트리**로서 DB 인덱스에서 사용하는 자료구조이다.
    - B - 트리는 이진 트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다. **최대 *M*개의 자식**을 가질 수 있는 B트리를 *M*차 B트리라 한다.
    - **범위 계산에 특화된 자료구조 !**
    - 항상 **정렬 상태를 유지**하고 있다.

![Untitled](https://user-images.githubusercontent.com/84346055/269582551-15900135-4b31-482e-9575-4f9068f154cb.png)

### B+ Tree

- MySQL 의 InnoDB에 사용되는 인덱스 자료구조
- 실제 **Data를 Leaf Node에만 저장**
    - 구조
        - **루트 노드 → 브랜치 노드 → 리프 노드**
        - B+ Tree 의 리프 노드들은 **더블 링크드 리스트로 연결**되어 있다.
- **Why ?**
    1. 하나의 블록에 더 많은 키를 저장할 수 있다.
        - 리프 노드를 제외하고는 데이터를 담아두지 않기 때문에 데이터를 더 확보할 수 있다.
        - 하나의 노드에 더 많은 키 저장 → 트리의 높이가 낮아짐
    2. (레인지)풀 스캔시 **B+Tree는 리프 노드에 데이터가 모두 있기 때문에 한번의 선형 탐색만 하면 되기 때문에 B-Tree 에 비해 빠르다.**
        - O(logN) + 선형 탐색

![Untitled](https://user-images.githubusercontent.com/84346055/269582582-03d26746-4343-4b18-b2ca-29e6e4feb18c.png)

## 인덱스 작업

### 인덱스 키 추가

- B - Tree 구조에 Key가 저장될때에는 저장될 키 값을 이용해 **적절한 위치 탐색**
    - 위치를 찾았다면 **레코드의 키 값**과 대상 **레코드의 주소 정보**를 리프 노드에 저장
    - 리프 노드가 전부 찼을 경우
        - Split ( 상위 브랜치 노드까지 처리의 범위가 확대된다. ) : 많은 비용 발생
            - 최악의 경우 root 노드까지 전파가 올라갈 수 있다.

![Untitled](https://user-images.githubusercontent.com/84346055/269582591-02cd2bff-00f6-429a-970f-8207b3045dc9.png)

### 인덱스 키 삭제

- 리프 노드 중 인덱스 키 값을 찾아서 삭제 마킹 처리
    - 마킹된 키 공간은 **재활용 가능**
    - 키 값이 가리키는 실제 데이터 레코드는 바로 삭제 처리가 되지 않는다.

### 인덱스 키 변경

- 키 값 → **저장될 리프 노드의 위치가 결정**된다.
    - 기존 Key 삭제 + 새로운 Key 추가 연산의 과정이 수행된다.
    - InnoDB 기준으로 Change Buffer 를 통해 지연 처리 가능

## 인덱스 키의 크기

- 페이지
    - **디스크와 메모리에 데이터를 읽고 쓰는 최소 단위 (페이지의 범위에 따라 디스크 I/O와 직결된다)**
    - 인덱스와 데이터 모두 데이터 베이스의 객체이기 때문에 페이지 단위로 관리한다.
- InnoDB 스토리지 엔진의 버퍼 풀
    - 데이터를 버퍼링하는 기본 단위 → 페이지
    - B - Tree 자료구조를 기준으로 노드 → 페이지 단위
- 인덱스를 구성하는 **키값의 크기가 커진다면?**
    - 디스크로부터 읽어야 하는 횟수가 증가하고 속도 측면에서 불리하다.

### B+ Tree의 깊이

- B+ Tree 의 깊이 → 데이터베이스 엔진에서 값을 검색할 때 몇번이나 랜덤 I/O (디스크에 접근)하는지와 관련
- 인덱스 페이지에 많은 인덱스를 담는 것이 랜덤 I/O를 줄일 수 있는 방법이다.

## Scan

### Full Table Scan

- 순차 접근
    - 원하는 데이터를 찾기 위해 **모든 데이터 요소를 순서대로 탐색**하는 방법 (선형 탐색)
    - 순차 I/O 를 사용한다.
- **Full Table Scan 사용 경우**
    1. 적용 가능한 인덱스가 없는 경우
    2. 인덱스의 처리 범위가 넓은 경우
        - **Full Table Scan > Index Range Scan**
    3. 크기가 작은 테이블(인덱스의 효과가 미비)인 경우

### Index Range Scan

- 검색해야 할 **인덱스 or 인덱스의 범위가 결정**되었을 때 사용하는 방식
    - 과정
        1. 인덱스 조건을 만족하는 값 탐색 ( 루트 → 브랜치 → 리프)
        2. 탐색 위치에서 필요한 만큼 인덱스를 읽는다 (레인지 스캔)
        3. 2번을 통해 인덱스 키와 레코드 주소를 이용해 페이지를 가져오고 (Random I/O) 최종적으로 레코드를 읽는다.


![Untitled](https://user-images.githubusercontent.com/84346055/269582595-6f3c2a0c-365d-404a-9426-3827d7d6c1a1.png)

- **데이터 파일 ?**

  ![Untitled](https://user-images.githubusercontent.com/84346055/269582598-21e00956-605b-4b61-a698-ef149447fffb.png)


### Index Full Scan

- 인덱스의 처음부터 끝까지 모두 읽는 방식
    - 쿼리의 조건절에서 다중 칼럼이 사용되는 경우 **인덱스의 첫 번째 칼럼이 아닌 경우**
    - 인덱스의 크기는 테이블의 크기보다 작으므로 인덱스에 명시된 칼럼으로만 쿼리 처리 가능 경우 사용

### Loose Index Scan

- 중간에 필요하지 않은 인덱스에 대해서는 SKIP하고 다음으로 넘어가는 형태
    - **Group By** **OR** **MIN() , MAX() 함수에 대해 최적화시 사용**

**ex)**

![Untitled](https://user-images.githubusercontent.com/84346055/269582602-4e942bd9-8387-415f-a56b-796792239c6e.png)

- 인덱스가 (dept_no , emp_no) 조합으로 정렬되어 있을 때 dept_no 그룹 별로 emp_no 레코드 값을 1개만 읽으면 된다.

## Multi -Column Index

- 다중 칼럼 인덱스
    - 인덱스의 키를 **두개 이상의 컬럼으로 구성**하는 경우

> 다중 칼럼 인덱스의 경우 2번째 컬럼은 1번째 컬럼에 의존하여 정렬되어 있다는 것. 복합 컬럼 인덱스 사용시 **컬럼의 순서가 중요**하다.
>

![Untitled](https://user-images.githubusercontent.com/84346055/269582604-3fe443f0-1792-49e3-92f1-3e975bd4d9e7.png)

- 정렬 순서를 혼합하여 복합 컬럼 인덱스 생성

![Untitled](https://user-images.githubusercontent.com/84346055/269582605-fb4bcd94-29b9-4cff-b307-7e701f051c54.png)

- 예시의 경우 team_name 을 기준으로는 **오름차순** , user_score을 기준으로 **내림차순**
- **정순(ASC) 스캔과 역순(DESC) 스캔의 차이**
    - InnoDB 스토리지 엔진 기준
        - 페이지 잠금이 정순에 유리한 구조
        - 페이지 내부에서 인덱스 레코드가 단방향으로 연결되어 있다. (Single Linked List)

## 참고

- Real -MySQL

[[MySQL 8.0] InnoDB 스토리지 엔진에서의 B+ Tree 인덱스를 통한 레코드 스캔 구조](https://velog.io/@msung99/MySQL-8.0-InnoDB-스토리지-엔진에서의-B-Tree-인덱스를-통한-레코드-데이터-스캔-최적화-구조)

# Index -2 (클러스터링 인덱스)

## 클러스터링 / 논 - 클러스터링 인덱스

### 클러스터링 인덱스

---

> 데이터가 저장되는 물리적인 형태가 저장된 인덱스
>
- 테이블의 레코드를 프라이머리 키(클러스터링 인덱스)를 기준으로 묶어서 저장하는 형태
    - MySQL에서 클러스터링 인덱스는 **InnoDB 스토리지 엔진**에서만 지원
- 테이블의 **프라이머리 키**에만 적용
    - PK 값이 변경된다면 레코드의 **물리적 저장 위치가 바뀐다.**
    - 즉 PK 값에 따라 자동으로 정렬된다.
- 물리적 저장 위치를 결정하기 때문에 테이블에 대해서 **오직 한개만 존재**할 수 있다.
- 인덱스 자체의 리프 페이지가 곧 데이터 → 테이블 자체가 인덱스
    - 별도의 **인덱스 페이지는 필요하지 않다 !**

장점

- PK(클러스터링 인덱스) 기반 검색이 빠르다.

단점

- 세컨더리 인덱스를 통한 겁색 → PK로 다시 한번 검색 (성능이 좋지 않다)
- 레코드의 저장이나 프라이머리 키의 변경에 대한 처리가 느리다.
    - PK 변경 → 레코드를 DELETE + INSERT
    - 위치를 재설정해야 하기 때문 !

![Untitled](https://user-images.githubusercontent.com/84346055/270346084-1446cb9e-a23b-463d-b46f-400d0586cc6e.png)

- 위 그림과 같이 PK(emp_no) 값을 기준으로 리프 노드(페이지)에 데이터가 정렬되어 저장되어 있는 것을 알 수 있다.
    - 클러스터링 인덱스 구조도 결국 B -Tree 기반이다. 하지만 **리프 노드의 데이터가 실제 레코드**라는 것이 중요하다.

      > 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것 !
>

![Untitled](https://user-images.githubusercontent.com/84346055/270346118-46d32be8-7ed2-4d8c-bf2b-eb2a17434f39.png)

- **PK가 없는 InnoDB 테이블의 경우 ?**

  다음의 과정을 수행

    1. PK가 있으면 기본적으로 PK가 클러스터링 인덱스
    2. NOT NULL + UNIQUE INDEX 중에서 첫 번째 인덱스를 클러스터링 인덱스로 선택
    3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적 추가 → 사용자에게 보여지진 않는다.

![Untitled](https://user-images.githubusercontent.com/84346055/270346134-6f35ac2f-417d-4ac0-94d7-551cf3d5ffce.png)

### 논 -클러스터링 인덱스

---

- 클러스터링 인덱스의 반대 , 군집화 되어 있지 않은 인덱스
- 데이터 행에 독립적이다.
    - 레코드의 **물리적 저장 위치가 변경되지 않는다.**
        - 레코드가 정렬되는 것이 아닌 인덱스 페이지가 정렬되는 것이다.
        - 별도의 인덱스 페이지를 위한 **저장 공간**이 필요하다.
- 한 테이블에 여러개일 수 있다. → 세컨더리 인덱스
- 인덱스 리프 페이지는 데이터가 위치하는 포인터(**RID → Row ID**)
    - 클러스터형보다 속도는 느리지만 데이터의 입력 , 수정 , 삭제는 빠르다.

![Untitled](https://user-images.githubusercontent.com/84346055/270346144-395738b0-bce1-4e37-84bc-5f485afd5515.png)

### InnoDB 세컨더리 인덱스

---

- 클러스터링 인덱스를 사용하지 않는 경우
    - **레코드가 저장된 공간의 위치**는 **인덱스 테이블과 독립적**이다.
    - 레코드가 저장된 주소 → 내부적인 레코드 아이디(ROWID) 역할
    - PK나 세컨더리 인덱스의 키는 그 주소(ROWID)를 이용하여 실제 데이터 레코드를 가져온다.

- InnoDB(클러스터링 인덱스 사용 경우)
    - 클러스터링 인덱스가 **물리적인 저장 위치**를 결정 !
        - 변경되는 경우 → ROWID가 재설정된다.
    - 세컨더리 인덱스의 리프 노드에 ROWID를 저장하는 경우
        - 클러스터링 인덱스가 변경 → 인덱스에 저장된 주솟값(ROWID) 변경

> 오버헤드를 제거하기 위해 InnoDB 테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 **PK값을 저장**
>

![Untitled](https://user-images.githubusercontent.com/84346055/270346153-7cf27493-5a12-42d6-bd52-bdc522b26fe4.png)

# Index -3 (Covering Index)

### Covering Index(커버링 인덱스)

- 쿼리를 수행하는데 있어 필요한 모든 데이터를 가지고 있는 **인덱스**
    - 커버링 인덱스를 효과적으로 사용한다면 **추가적인 데이터 접근은 필요하지 않다 !**

> SELECT, WHERE, ORDER BY, GROUP BY 등에 사용되는 모든 컬럼이 인덱스의 구성요소인 경우
>

- 예시 테이블

```
CREATE TABLE students (
	id
	name
	grade
	school
)
```

- id가 PK라고 했을 때 Index가 생성될 것이다.

> grade에도 index를 생성하고 grade =3 인 학생을 조회해보자 !
>

```
SELECT * FROM students WHERE grade = 3;
```

1. grade를 통한 검색 시 grade에 생성한 index를 통해서 빠르게 검색
2. grade가 아닌 name , school 칼럼에 대해서는 PK를 통한 2차 검색 필요
3. 결국 인덱스를 통한 검색 과정이 2번 수행된다 !
- **WHY ?**

  grade를 통해 생성한 index의 리프노드에는 PK만 저장되어 있다. 그렇기 때문에 name , school 등의 컬럼 정보를 가져오기 위해서는 **PK를 통한 2차 검색**이 필요하다.

    - grade를 통해 생성한 인덱스 → 논 클러스터링 인덱스
        - 리프 노드에는 **PK값이 저장**
    - PK로 생성된 인덱스 → 클러스터링 인덱스

![Untitled](https://user-images.githubusercontent.com/84346055/270674762-270ea788-b887-4086-80d5-31f77998140f.png)

- 이것이 문제인 이유 ?

> 앞서 말했지만 데이터 베이스의 성능에 크게 영향을 주는 것은 Disk I/O이다. **PK값을 통한 추가적인 레코드 접근 시 많은 시간**이 소요된다.
>
- **해결 !**

  추가적인 (데이터 블록)에 대한 레코드 접근(Disk I/O) 없이 데이터를 조회할 수 없을까 ? → **커버링 인덱스**


```
SELECT grade FROM students WHERE grade = 3;
```

- 위와 같은 쿼리는 실행 시 grade로 생성한 index 탐색만 하여 추가적인 레코드 접근은 발생하지 않는다.

### 커버링 인덱스 + PK

```
SELECT id FROM students WHERE grade = 3;
```

- **위의 쿼리는 추가적인 INDEX 탐색을 할까 ?**

  NO !! , 한번의 인덱스 탐색으로 id값을 반환한다 → 커버링 인덱스의 사용


**WHY**

- InnoDB의 세컨더리 인덱스의 구조
    - B -Tree 기반의 논 클러스러링 인덱스
    - 리프 노드에는 ROWID가 아닌 **PK** 저장
